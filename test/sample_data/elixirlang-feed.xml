
<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" media="screen" href="/~d/styles/atom10full.xsl"?><?xml-stylesheet type="text/css" media="screen" href="http://feeds.feedburner.com/~d/styles/itemcontent.css"?><feed xmlns="http://www.w3.org/2005/Atom">
 
<title>Elixir Lang</title>

<link href="http://elixir-lang.org" />
<updated>2015-06-25T18:25:14+00:00</updated>
<id>http://elixir-lang.org</id>


<atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="self" type="application/atom+xml" href="http://feeds.feedburner.com/ElixirLang" /><feedburner:info xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0" uri="elixirlang" /><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="hub" href="http://pubsubhubbub.appspot.com/" /><entry>
  <title>Elixir v1.0 released</title>
  <link href="http://elixir-lang.org/blog/2014/09/18/elixir-v1-0-0-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2014-09-18T00:00:00+00:00</updated>
  <id>/blog/2014/09/18/elixir-v1-0-0-released</id>
  <content type="html">&lt;p&gt;Hello everyone!&lt;/p&gt;

&lt;p&gt;We are glad to announce Elixir v1.0 is finally out. It has been 8005 commits &lt;a href="https://github.com/elixir-lang/elixir/graphs/contributors"&gt;by 189 contributors&lt;/a&gt;, including the initial commit on &lt;a href="https://github.com/elixir-lang/elixir/commit/337c3f2d569a42ebd5fcab6fef18c5e012f9be5b"&gt;January 9th, 2011&lt;/a&gt;!&lt;/p&gt;

&lt;h2 id="what-39-s-elixir"&gt;What&amp;#39;s Elixir?&lt;/h2&gt;

&lt;p&gt;Elixir is a dynamic, functional language designed for building scalable and maintainable applications.&lt;/p&gt;

&lt;p&gt;Elixir leverages the Erlang VM, known for running low-latency, distributed and fault-tolerant systems, while also being successfully used in web development and the embedded software domain.&lt;/p&gt;

&lt;h2 id="what-39-s-new"&gt;What&amp;#39;s new?&lt;/h2&gt;

&lt;p&gt;This release is the consolidation of all the work done through the years. With v1.0, we have reached a stable milestone for the growth of software and projects written in Elixir.&lt;/p&gt;

&lt;p&gt;Elixir will follow &lt;a href="http://semver.org"&gt;semantic versioning&lt;/a&gt;, which means code written for Elixir v1.0 will continue to compile and run correctly for all versions under the v1 branch (e.g. v1.0.1, v1.1.0, v1.2.0).&lt;/p&gt;

&lt;p&gt;Elixir is composed of 6 applications, all under the same versioning constraints:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="/docs/stable/elixir/"&gt;Elixir&lt;/a&gt; - the Elixir compiler, runtime and the standard library&lt;/li&gt;
&lt;li&gt;&lt;a href="/docs/stable/eex/"&gt;EEx&lt;/a&gt; - Elixir&amp;#39;s templating library, useful for generating any kind of document dynamically&lt;/li&gt;
&lt;li&gt;&lt;a href="/docs/stable/ex_unit/"&gt;ExUnit&lt;/a&gt; - Elixir&amp;#39;s unit test library, with support for concurrent testing, custom formatters, filters and much more&lt;/li&gt;
&lt;li&gt;&lt;a href="/docs/stable/iex/"&gt;IEx&lt;/a&gt; - Elixir&amp;#39;s interactive shell with code reloading, auto-complete, and easy access to documentation, typespecs and more&lt;/li&gt;
&lt;li&gt;&lt;a href="/docs/stable/logger/"&gt;Logger&lt;/a&gt; - the latest addition to the group, Logger provides reliable logging and configurable backends (with syslog, file and many other backends provided by the community)&lt;/li&gt;
&lt;li&gt;&lt;a href="/docs/stable/mix/"&gt;Mix&lt;/a&gt; - Elixir&amp;#39;s build tool that generates, compiles and tests projects as well as manages your dependencies&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With v1.0, we are providing a stable platform for the community to leverage and extend, and we are extremely excited with the projects and possibilities that are ahead of us!&lt;/p&gt;

&lt;p&gt;We hope the &lt;a href="http://hex.pm"&gt;Hex package manager&lt;/a&gt; will be the home of many of those projects and remember the whole Erlang ecosystem is also available to Elixir developers.&lt;/p&gt;

&lt;h2 id="expectations"&gt;Expectations&lt;/h2&gt;

&lt;p&gt;We would like to elaborate on the expectations regarding Elixir v1.0. Although we expect that the vast majority of programs will remain compatible over time, it is impossible to guarantee that no future change will break any program.&lt;/p&gt;

&lt;p&gt;Under some unlikely circumstances, we may introduce changes that break existing code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Security: a security issue in the implementation may arise whose resolution requires backwards incompatible changes. We reserve the right to address such security issues.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Bugs: if an application has undesired behaviour, a program that depends on the buggy behaviour may break if the bug is fixed. We reserve the right to fix such bugs.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Compiler front-end: improvements may be done to the compiler, introducing new warnings for ambiguous modes and providing more detailed error messages. Those can lead to compilation errors (when running with &lt;code&gt;--warning-as-errors&lt;/code&gt;) or tooling failures when asserting on specific error messages (although one should avoid such). We reserve the right to do such improvements.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Imports: new functions may be added to the Kernel module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; with a list of all functions you don&amp;#39;t want imported from Kernel. We reserve the right to do such additions.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Elixir binaries are guaranteed to be backwards compatible within the same branch. Code compiled with v1.0 shall work with Elixir v1.0.1 runtime but code compiled with Elixir v1.0 should be recompiled to work with Elixir v1.1.0 onwards.&lt;/p&gt;

&lt;p&gt;These expectations also apply to future releases under the v1 branch, except for experimental features, which will be explicitly marked as such and not provide any compatibility guarantee until they are stabilized.&lt;/p&gt;

&lt;h2 id="learn-more"&gt;Learn more&lt;/h2&gt;

&lt;p&gt;You can get started with Elixir via our &lt;a href="/getting-started/introduction.html"&gt;Getting Started guide&lt;/a&gt;. There are quite some Elixir books out there too, now getting sent to the presses, quite a few can be found in the sidebar, which also includes screencasts and other resources.&lt;/p&gt;

&lt;p&gt;You can also learn more about Elixir by checking out &lt;a href="http://www.confreaks.com/events/elixirconf2014"&gt;the videos from ElixirConf 2014&lt;/a&gt;, the first (and so far the best) Elixir conference ever! You can learn more about &lt;a href="http://www.confreaks.com/videos/4134-elixirconf2014-keynote-elixir"&gt;the language history&lt;/a&gt;, &lt;a href="http://www.confreaks.com/videos/4119-elixirconf2014-opening-keynote-think-different"&gt;how Elixir can change the way you code&lt;/a&gt; or &lt;a href="http://www.confreaks.com/videos/4131-elixirconf2014-otp-in-production-the-nitty-gritty-details-of-game-servers"&gt;even hear stories of how Elixir is being used in production&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, by popular demand, we have &lt;a href="http://www.stickermule.com/user/1070631438/stickers"&gt;released some Elixir stickers&lt;/a&gt;, which are available with a discounted price to celebrate v1.0!&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.15.0 released</title>
  <link href="http://elixir-lang.org/blog/2014/08/07/elixir-v0-15-0-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2014-08-07T00:00:00+00:00</updated>
  <id>/blog/2014/08/07/elixir-v0-15-0-released</id>
  <content type="html">&lt;p&gt;Hello everyone!&lt;/p&gt;

&lt;p&gt;We are glad to announce v0.15.0 has been released. We have spent the last 2 months tidying up the existing APIs, ensuring consistency, improving performance and more. As a result, v0.15.0 is the last minor branch before Elixir v1.0!&lt;/p&gt;

&lt;p&gt;There are also no more planned deprecations nor backward incompatible changes which means it is extremely likely that code that runs on v0.15.0 will run exactly the same on Elixir v1.0.&lt;/p&gt;

&lt;p&gt;If you are interested in the specific details for this release, &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.15.0/CHANGELOG.md"&gt;please check our CHANGELOG&lt;/a&gt;. In this post, we will focus on three new features in this release: Logger, Mix aliases, the fresh Elixir Web Installer for Windows, and share some exciting news at the end!&lt;/p&gt;

&lt;h2 id="logger"&gt;Logger&lt;/h2&gt;

&lt;p&gt;Elixir now ships with a new application called logger. This application provides &lt;a href="/docs/stable/logger/#!Logger.html"&gt;the Logger module&lt;/a&gt;, which is the main API developers will use for logging:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kn"&gt;require&lt;/span&gt; &lt;span class="nc"&gt;Logger&lt;/span&gt;
&lt;span class="nc"&gt;Logger&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By default, the code above will log the following message to your console:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;10:27:39.083 [debug] hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Logger provides multiple backends to where messages are logged. For now Elixir ships only with a console backend but there are developers already working on file (with support to external log rotation) and &lt;a href="http://en.wikipedia.org/wiki/Syslog"&gt;syslog&lt;/a&gt; backends.&lt;/p&gt;

&lt;p&gt;When we started Logger, the main objective was to translate Erlang messages into Elixir, so terms are formatted in Elixir syntax. Before this release, the following code&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="nc"&gt;Task&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;async&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;oops&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;logged the following report:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;=ERROR REPORT==== 7-Aug-2014::10:35:59 ===
** Task &amp;lt;0.59.0&amp;gt; terminating
** Started from &amp;lt;0.53.0&amp;gt;
** When function  == #Fun&amp;lt;erl_eval.20.90072148&amp;gt;
**      arguments == []
** Reason for termination ==
** {#{&amp;#39;__exception__&amp;#39; =&amp;gt; true,&amp;#39;__struct__&amp;#39; =&amp;gt; &amp;#39;Elixir.RuntimeError&amp;#39;,message =&amp;gt; &amp;lt;&amp;lt;&amp;quot;oops&amp;quot;&amp;gt;&amp;gt;},
    [{&amp;#39;Elixir.Task.Supervised&amp;#39;,do_apply,2,
                               [{file,&amp;quot;lib/task/supervised.ex&amp;quot;},{line,70}]},
     {&amp;#39;Elixir.Task.Supervised&amp;#39;,async,3,
                               [{file,&amp;quot;lib/task/supervised.ex&amp;quot;},{line,15}]},
     {proc_lib,init_p_do_apply,3,[{file,&amp;quot;proc_lib.erl&amp;quot;},{line,239}]}]}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, with Logger, we get this report:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;10:37:22.457 [error] Task #PID&amp;lt;0.72.0&amp;gt; started from #PID&amp;lt;0.60.0&amp;gt; terminating
Function: #Function&amp;lt;20.90072148/0 in :erl_eval.expr/5&amp;gt;
    Args: []
** (exit) an exception was raised:
    ** (RuntimeError) oops
        (elixir) lib/task/supervised.ex:70: Task.Supervised.do_apply/2
        (elixir) lib/task/supervised.ex:15: Task.Supervised.async/3
        (stdlib) proc_lib.erl:239: :proc_lib.init_p_do_apply/3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As soon as we started working on Logger, we realized we could go further than simply translating Erlang messages and provide a fully featured logger library. At this moment, Logger also supports:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;4 log levels: debug, info, warn and error&lt;/li&gt;
&lt;li&gt;Custom formatting: you can specify a format string that tells exactly how messages should be logged. The default string is: &amp;quot;$time $metadata[$level] $message\n&amp;quot; but &lt;a href="/docs/stable/logger/#!Logger.Formatter.html"&gt;many attributes are supported&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Custom translators: so you can translate log messages coming from any Erlang application into Elixir syntax&lt;/li&gt;
&lt;li&gt;Metadata: metadata allows developers to store information in the current process that will be available to all logged messages. For example, a web application can generate a &lt;code&gt;request_id&lt;/code&gt;, store it as metadata, and all messages logged during that request will be properly identified with &lt;code&gt;request_id=...&lt;/code&gt; in the log&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have also relied a lot on the &lt;a href="http://www.youtube.com/watch?v=8BNpOHFvg_Q"&gt;research and work done by Andrew Thompson and the folks at Basho behind Lager&lt;/a&gt; to ensure our logger is performant and robust. On this front, Logger&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;alternates between sync and async modes when logging messages to keep it performant when required but also apply back-pressure when under stress&lt;/li&gt;
&lt;li&gt;formats and truncates messages on the client to avoid clogging the backends&lt;/li&gt;
&lt;li&gt;provide a highwater mark around Erlang&amp;#39;s error_logger to avoid it from overflowing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We are looking forward to everyone&amp;#39;s feedback on using Logger more and more in production.&lt;/p&gt;

&lt;h2 id="mix-aliases"&gt;Mix aliases&lt;/h2&gt;

&lt;p&gt;Mix is Elixir&amp;#39;s build tool. Mix knows how to manage your dependencies, compile &amp;amp; test your projects and much more. We have designed Mix, since day one, to be extensible. Developers were always able to define new tasks by simply defining a module:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmodule&lt;/span&gt; &lt;span class="nc"&gt;Mix.Tasks.Hello&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="nc"&gt;Mix.Task&lt;/span&gt;

  &lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="nc"&gt;IO&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Hello world&amp;quot;&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The task above can now be invoked as &lt;code&gt;mix hello&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Defining custom Mix tasks is useful for projects and libraries that want to better integrate with the standard development workflow for Elixir. However, it is a bit verbose for creating one-off tasks or tasks to be used only locally in a given project.&lt;/p&gt;

&lt;p&gt;Furthermore, so far Mix did not allow developers to extend existing tasks. For example, imagine you want to perform some extra work when &lt;code&gt;mix clean&lt;/code&gt; is invoked. Up to this release, it was not possible.&lt;/p&gt;

&lt;p&gt;Mix aliases solve both problems by providing a simple API for defining and overriding aliases. All projects that use Mix contain a &lt;code&gt;mix.exs&lt;/code&gt; file with the project configuration. In order to define an alias, you just need to add a new key to your project configuration:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmodule&lt;/span&gt; &lt;span class="nc"&gt;MyProject&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="nc"&gt;Mix.Project&lt;/span&gt;

  &lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;project&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;app&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="ss"&gt;:my_project&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
     &lt;span class="ss"&gt;aliases&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;aliases&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="kd"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;aliases&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;compile&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
     &lt;span class="ss"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;print_hello&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
     &lt;span class="ss"&gt;clean&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;clean&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;clean_vendor&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="kd"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;print_hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;_&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nc"&gt;IO&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Hello world&amp;quot;&lt;/span&gt;
  &lt;span class="kd"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;clean_vendor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;_&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rm_rf!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;vendor&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the project above, we have defined three aliases:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mix c&lt;/code&gt; - is now a shortcut to &lt;code&gt;mix compile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mix hello&lt;/code&gt; - is equivalent to the &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; we have defined earlier, although now it is more easily defined as an alias&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mix clean&lt;/code&gt; - extends the existing &lt;code&gt;clean&lt;/code&gt; task to ensure we invoke &lt;code&gt;clean_vendor/1&lt;/code&gt; afterwards&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In other words, aliases can be three different structures:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A string containing the task and arguments to be invoked&lt;/li&gt;
&lt;li&gt;An anonymous function (that is invoked passing the task arguments)&lt;/li&gt;
&lt;li&gt;A list containing strings or anonymous functions&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can find more information about aliases by reading the &lt;a href="/docs/stable/mix/"&gt;Mix documentation&lt;/a&gt; (there is a section about Aliases around the middle).&lt;/p&gt;

&lt;p&gt;We also would like to thank &lt;a href="https://github.com/raynes"&gt;Anthony Grimes&lt;/a&gt; for the support and &lt;a href="https://github.com/technomancy"&gt;Phil Halgelberg&lt;/a&gt; for &lt;a href="https://github.com/technomancy/leiningen"&gt;the work on Lein&lt;/a&gt; which Mix borrows a lot from.&lt;/p&gt;

&lt;h2 id="elixir-web-installer-for-windows"&gt;Elixir Web Installer for Windows&lt;/h2&gt;

&lt;p&gt;At the beginning of this summer, &lt;a href="http://github.com/chyndman"&gt;Chris Hyndman&lt;/a&gt; joined us as a Google Summer of Code student to help us improve the Elixir story on Windows. Chris has been essential in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Guaranteeing our test suite is green on Windows, fixing many bugs in the process;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/elixir-lang/elixir/wiki/Windows"&gt;Documenting how to compile Elixir from source on Windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Ensuring important projects like our &lt;a href="https://github.com/devinus/markdown/pull/7"&gt;C markdown processor&lt;/a&gt; compiles on Windows&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Chris has also built an &lt;a href="https://github.com/elixir-lang/elixir-windows-setup"&gt;Elixir Web Installer for Windows&lt;/a&gt;. The web installer checks all available Elixir versions and allows you to pick which one to install. It will also fetch and install Erlang in your machine in case it has not been installed yet.&lt;/p&gt;

&lt;p&gt;If you want to give Elixir and the Web Installer a try, you can &lt;a href="http://s3.hex.pm/elixir-websetup.exe"&gt;download the current version here&lt;/a&gt;. And, if &lt;a href="https://chocolatey.org/"&gt;Chocolatey&lt;/a&gt; is your thing, remember you can also install Elixir on Windows by running &lt;code&gt;cinst elixir&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="welcome-alexei"&gt;Welcome Alexei!&lt;/h2&gt;

&lt;p&gt;With v0.15.0, we also would like to welcome &lt;a href="https://github.com/alco"&gt;Alexei&lt;/a&gt; to the team of Elixir Maintainers! Alexei was one of the first to actively participate in the Elixir community and he has done an excellent job in guaranteeing quality throughout it, be it in the code, documentation, wiki or website.&lt;/p&gt;

&lt;p&gt;Alexei is also interested in how we can extend our tooling to the Erlang ecosystem as a whole, bringing Mix and Hex (our package manager) to more developers as well as adding tasks that are specific to Erlang projects.&lt;/p&gt;

&lt;h2 id="what-39-s-next"&gt;What&amp;#39;s next?&lt;/h2&gt;

&lt;p&gt;We are very close to launch Elixir v1.0! All planned features are already in Elixir&amp;#39;s codebase and at the moment there are only &lt;a href="https://github.com/elixir-lang/elixir/issues?q=is%3Aopen+is%3Aissue+milestone%3Av1.0"&gt;four open issues in our tracker tagged with the v1.0 milestone&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our estimated date for the first release candidate for Elixir v1.0 is August 30th. This means there is no better time to learn Elixir than now! If you haven&amp;#39;t started yet, you can get started with Elixir by reading &lt;a href="/getting-started/introduction.html"&gt;our Getting Started guide&lt;/a&gt; or by checking one of the many &amp;quot;Learning Resources&amp;quot; on the sidebar.&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.14.0 released</title>
  <link href="http://elixir-lang.org/blog/2014/06/17/elixir-v0-14-0-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2014-06-17T00:00:00+00:00</updated>
  <id>/blog/2014/06/17/elixir-v0-14-0-released</id>
  <content type="html">&lt;p&gt;Hello everyone!&lt;/p&gt;

&lt;p&gt;We are glad to announce v0.14.0 has been released.&lt;/p&gt;

&lt;p&gt;Our previous release, &lt;a href="/blog/2014/04/21/elixir-v0-13-0-released/"&gt;v0.13.0&lt;/a&gt;, brought important changes to the language. Back then we have introduced a new associative data structure, called maps, and presented the concept of structs to replace Elixir records.&lt;/p&gt;

&lt;p&gt;With v0.14.0 we have expanded on the work started on v0.13.0, replacing records by structs and integrating OTP behaviours, applications, and configurations into Mix.&lt;/p&gt;

&lt;h2 id="derive"&gt;@derive&lt;/h2&gt;

&lt;p&gt;Maps are Elixir&amp;#39;s new associative data structure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="p"&gt;%{&lt;/span&gt;&lt;span class="ss"&gt;key&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With maps, Elixir also introduced structs, that are basically raw, named maps:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmodule&lt;/span&gt; &lt;span class="nc"&gt;User&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kd"&gt;defstruct&lt;/span&gt; &lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;age&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;jose&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; %User{name: &amp;quot;jose&amp;quot;, age: 0}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Structs allow us to provide default values for a map fields. Structs also validate, at compilation time, that all fields given during the struct construction are valid fields. The following, for example, would fail:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;unknown&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;field&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; ** (CompileError) iex:2: unknown key :unknown for struct User&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We say structs are &lt;em&gt;raw&lt;/em&gt; because they do not implement any of the protocols that are implemented for maps  by default. For instance, we can call &lt;code&gt;Enum.each/2&lt;/code&gt; for a map, which uses the &lt;a href="/docs/stable/elixir/#!Enumerable.html"&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="nc"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="p"&gt;%{&lt;/span&gt;&lt;span class="ss"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="ss"&gt;:bar&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="nc"&gt;IO&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Got &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;: &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; Got foo: bar&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But such a call would fail for the User struct:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="nc"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="nc"&gt;IO&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Got &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;: &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; ** (Protocol.UndefinedError) protocol Enumerable not implemented for %User{age: 0, name: &amp;quot;&amp;quot;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, in many situations, we may want to enumerate the keys and values in a struct. Before this release, it would require us to manually implement the &lt;code&gt;Enumerable&lt;/code&gt; protocol for every struct.&lt;/p&gt;

&lt;p&gt;Elixir v0.14.0 solves this issue by introducing &lt;code&gt;@derive&lt;/code&gt; which allows us to dynamically derive implementations for structs based on the implementation for maps:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmodule&lt;/span&gt; &lt;span class="nc"&gt;User&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="na"&gt;@derive&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nc"&gt;Enumerable&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="kd"&gt;defstruct&lt;/span&gt; &lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;age&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="nc"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;jose&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="nc"&gt;IO&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Got &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;: &lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; Got __struct__: Elixir.User&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; Got name: jose&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; Got age: 0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The deriving functionality can be customized by implementing &lt;code&gt;PROTOCOL.Map.__deriving__/3&lt;/code&gt;. For example, a JSON protocol could define a &lt;code&gt;JSON.Map.__deriving__/3&lt;/code&gt; function that derives specific implementations for every struct. Such implementations could access the struct fields and generate a JSON template at compilation time, avoiding work at runtime.&lt;/p&gt;

&lt;h2 id="protocol-consolidation"&gt;Protocol consolidation&lt;/h2&gt;

&lt;p&gt;In the example above, when we called &lt;code&gt;Enum.each/2&lt;/code&gt;, it invoked the &lt;code&gt;Enumerable&lt;/code&gt; protocol internally, which then checks if there is an implementation available for the &lt;code&gt;User&lt;/code&gt; struct. This means that dispatching a protocol incurs some overhead to check if the implementation is available or not.&lt;/p&gt;

&lt;p&gt;While this behaviour is useful for development, in production all implementations for all protocols are usually known up-front, so we could avoid this overhead by doing a direct dispatch. That&amp;#39;s exactly what protocol consolidation does.&lt;/p&gt;

&lt;p&gt;Protocol consolidation checks all code paths in your project, looking for all protocols and all implementions. When all implementations are found it will recompile all protocols to have quick dispatch rules.&lt;/p&gt;

&lt;p&gt;You can invoke &lt;code&gt;Protocol.consolidate/2&lt;/code&gt; to manually consolidate protocols. However, if you are inside a Mix project, you can consolidate all protocols by simply invoking &lt;code&gt;mix compile.protocols&lt;/code&gt;. Type &lt;code&gt;mix help compile.protocols&lt;/code&gt; in your terminal to get more information. This task should be invoked when deploying to production and we have opened issues in the Elixir buildpack as well as in the existing build tools so they automatically consolidade protocols for you.&lt;/p&gt;

&lt;h2 id="nested-access"&gt;Nested access&lt;/h2&gt;

&lt;p&gt;With v0.14.0, Elixir introduced functionality to traverse deeply nested data structures. To show this functionality let&amp;#39;s imagine we have a gaming application where users can be in different dungeons. Each dungeon may have many rooms and users can talk to each other only if they are in the same room.&lt;/p&gt;

&lt;p&gt;We can model the game&amp;#39;s dungeons with a Dungeon struct:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="nc"&gt;Dungeon&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;rooms&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;%{}}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The Dungeon can have many rooms and we keep them in a map, with the room id as key, and the Room struct as value:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="nc"&gt;Room&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;users&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nc"&gt;HashDict&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A room has users and since we can possibly have hundreds of them, we store them in a HashDict, with the user id as key. Finally, the user may participate from different devices, so we need to keep a set of device codes in each user:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;username&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;device_codes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nc"&gt;HashSet&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The nested access functionality that ships with Elixir allows us to quickly access or update a nested value. For example, given a dungeon named &lt;code&gt;dungeon&lt;/code&gt;, we can access all the device codes for a given user as follow:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="n"&gt;dungeon&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rooms&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;room_id&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;users&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;user_id&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;device_codes&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the nested access functionality, we can now update a nested path directly too. For example, if a user changes his name, we can change it directly with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="n"&gt;put_in&lt;/span&gt; &lt;span class="n"&gt;dungeon&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rooms&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;room_id&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;users&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;user_id&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;new username&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If the user signs out from one device, we can delete the code from that particular device:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="n"&gt;update_in&lt;/span&gt; &lt;span class="n"&gt;dungeon&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rooms&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;room_id&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;users&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;user_id&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;device_codes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nc"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ni"&gt;&amp;amp;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;put_in/2&lt;/code&gt; and &lt;code&gt;update_in/2&lt;/code&gt; are macros that work as syntax sugar for the lower-level &lt;code&gt;put_in/3&lt;/code&gt; and &lt;code&gt;update_in/3&lt;/code&gt;, that expects the whole path to be given as a list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="n"&gt;put_in&lt;/span&gt; &lt;span class="n"&gt;dungeon&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:rooms&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;room_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:users&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;user_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;new username&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can read more information about nested access in &lt;a href="/docs/stable/elixir/#!Access.html"&gt;the Access protocol documentation&lt;/a&gt; and in the docs for &lt;a href="/docs/stable/elixir/#!Kernel.html#get_in/2"&gt;&lt;code&gt;get_in/2&lt;/code&gt;&lt;/a&gt; and friends.&lt;/p&gt;

&lt;h2 id="mix-and-otp"&gt;Mix and OTP&lt;/h2&gt;

&lt;p&gt;OTP is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications.&lt;/p&gt;

&lt;p&gt;In v0.14.0, Elixir closely integrates with OTP by providing modules for building &lt;a href="/docs/stable/elixir/#!GenServer.html"&gt;servers&lt;/a&gt;, &lt;a href="/docs/stable/elixir/#!GenEvent.html"&gt;event managers and event handlers&lt;/a&gt;, &lt;a href="/docs/stable/elixir/#!Supervisor.html"&gt;supervisors&lt;/a&gt; and &lt;a href="/docs/stable/elixir/#!Application.html"&gt;applications&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We have also introduced the concepts of &lt;a href="/docs/stable/elixir/#!Agent.html"&gt;agents&lt;/a&gt; and the idea of &lt;a href="/docs/stable/elixir/#!Task.html"&gt;tasks&lt;/a&gt;, which can be supervised and distributed. Application configuration has been made first class in Mix, allowing developers to configure their dependencies, sometimes even using different configurations per environment (dev, test or prod by default).&lt;/p&gt;

&lt;p&gt;This functionality is at the core of building applications in Erlang and Elixir. For this reason we have published a new guide called &lt;a href="/getting-started/mix-otp/introduction-to-mix.html"&gt;Mix and OTP&lt;/a&gt; where we build a distributed key-value store to help explore all concepts mentioned above. The guide is quite fresh, so please do submit pull requests for typos and mistakes. Feedback is also welcome!&lt;/p&gt;

&lt;p&gt;Note &amp;quot;Mix and OTP&amp;quot; is our most advanced guide so far and it expects you to have read our introductory guide. In case you haven&amp;#39;t yet, you can &lt;a href="/getting-started/introduction.html"&gt;get started here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="what-39-s-next"&gt;What&amp;#39;s next?&lt;/h2&gt;

&lt;p&gt;With v0.14.0 we have reached many of the milestones &lt;a href="/blog/2014/04/21/elixir-v0-13-0-released/#the-next-steps"&gt;we have set in the previous release&lt;/a&gt;. This brings us closer to Elixir v1.0 and only a handful of tasks are pending:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Provide an Elixir logger that knows how to print and format Elixir exceptions and stacktraces. Work has already started on this front as Elixir already prints errors coming from the application startup nicely;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Continue the work of cleaning up the &lt;a href="/docs/stable/elixir/#!Kernel.html"&gt;Kernel module&lt;/a&gt;. In v0.14.0, we added alternatives for conversion functions, like &lt;code&gt;integer_to_binary/1&lt;/code&gt; to &lt;code&gt;Integer.to_string/1&lt;/code&gt;, now they must be properly deprecated and removed;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Support mix aliases, allowing developers to easily define Mix shortcuts for their favorite tasks;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Solve all remaining &lt;a href="https://github.com/elixir-lang/elixir/issues?state=open"&gt;open issues&lt;/a&gt;. We have always kept the issues tracker tidy and there is little work left to solve the existing issues. Note we have also listed all &lt;a href="https://github.com/elixir-lang/elixir/issues?labels=Note%3ABackwards+incompatible&amp;amp;page=1&amp;amp;state=open"&gt;upcoming backwards incompatible changes&lt;/a&gt;. Many of those changes will actually be deprecated first and developers should be able to follow along without breaking changes in minor releases, but they are breaking changes in the sense they work in v0.14.0 but will work differently by the time v1.0 is released;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That&amp;#39;s all for now! Elixir developers can see &lt;a href="https://github.com/elixir-lang/elixir/releases/tag/v0.14.0"&gt;a summary of all changes in v0.14.0 in the release notes&lt;/a&gt;. In case you are new around here, you can get started with Elixir by reading &lt;a href="/getting-started/introduction.html"&gt;our Getting Started guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We hope to see you all this July at &lt;a href="http://elixirconf.com/"&gt;ElixirConf&lt;/a&gt;!&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.13.0 released, hex.pm and ElixirConf announced</title>
  <link href="http://elixir-lang.org/blog/2014/04/21/elixir-v0-13-0-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2014-04-21T00:00:00+00:00</updated>
  <id>/blog/2014/04/21/elixir-v0-13-0-released</id>
  <content type="html">&lt;p&gt;Hello folks!&lt;/p&gt;

&lt;p&gt;Elixir v0.13.0 has been released. It contains changes that will effectively shape how developers will write Elixir code from now on, making it an important milestone towards v1.0! On this post we are going to cover some of those changes, the road to Elixir v1.0, as well as the announcement of &lt;a href="http://hex.pm"&gt;hex.pm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before we go into the changes, let&amp;#39;s briefly talk about ElixirConf!&lt;/p&gt;

&lt;h2 id="elixirconf"&gt;ElixirConf&lt;/h2&gt;

&lt;p&gt;We are excited to announce &lt;a href="http://elixirconf.com"&gt;ElixirConf&lt;/a&gt;, the first ever Elixir conference, happening July 25-26, 2014 in Austin, TX. The Call For Proposals is open and we are waiting for your talks!&lt;/p&gt;

&lt;p&gt;The registration is also open and we hope you will join us on this exciting event. We welcome Elixir developers and enthusiasts that are looking forward to be part of our thrilling community!&lt;/p&gt;

&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;

&lt;p&gt;In a nutshell, here is what new:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Elixir now runs on and requires Erlang R17;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;With Erlang R17, Elixir also adds support for maps, which are key-value data structures that supports pattern matching. We&amp;#39;ll explore maps, their features and limitations in this post;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elixir v0.13 also provides structs, an alternative to Elixir records. Structs are more flexible than records, provide faster polymorphic operations, and still provide the same compile-time guarantees many came to love in records;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href="/getting-started/introduction.html"&gt;Getting Started guide&lt;/a&gt; was rewritten from scratch. The previous guide was comprised of 7 chapters and was about to become 2 years old. The new guide features 20 chapters, it explores the new maps and structs (which are part of this release), and it goes deeper into topics like IO and File handling. It also includes an extra guide, still in development, about &lt;a href="/getting-started/meta/quote-and-unquote.html"&gt;Meta-Programming in Elixir&lt;/a&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Elixir v0.13 provides a new comprehension syntax that not only works with lists, but with any &lt;a href="/docs/stable/elixir/#!Enumerable.html"&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt;. The output of a comprehension is also extensible via the &lt;a href="/docs/stable/elixir/#!Collectable.html"&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Mix, Elixir&amp;#39;s build tool, has been improved in order to provide better workflows when compiling projects and working with dependencies;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There are many other changes, like the addition of &lt;a href="/docs/stable/elixir/#!StringIO.html"&gt;StringIO&lt;/a&gt;, support for &lt;a href="/docs/stable/ex_unit/#!ExUnit.Case.html"&gt;tags and filters in ExUnit&lt;/a&gt; and more. Please check the &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.13.0/CHANGELOG.md"&gt;CHANGELOG&lt;/a&gt; for the complete list.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Even with all those improvements, Elixir v0.13.0 is backwards compatible with Elixir v0.12.5 and upgrading should be a clean process. &lt;/p&gt;

&lt;h2 id="maps"&gt;Maps&lt;/h2&gt;

&lt;p&gt;Maps are key-value data structures:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-iex" data-lang="iex"&gt;&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;%{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="ss"&gt;:world&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="go"&gt;%{&amp;quot;hello&amp;quot; =&amp;gt; :world}&lt;/span&gt;
&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="go"&gt;:world&lt;/span&gt;
&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:other&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="go"&gt;nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Maps do not have a explicit ordering and keys and values can be any term.&lt;/p&gt;

&lt;p&gt;Maps can be pattern matched on:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-iex" data-lang="iex"&gt;&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="p"&gt;%{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;world&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;
&lt;span class="go"&gt;%{&amp;quot;hello&amp;quot; =&amp;gt; :world}&lt;/span&gt;
&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt;
&lt;span class="go"&gt;:world&lt;/span&gt;
&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="p"&gt;%{}&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;
&lt;span class="go"&gt;%{&amp;quot;hello&amp;quot; =&amp;gt; :world}&lt;/span&gt;
&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="p"&gt;%{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;other&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;
&lt;span class="gr"&gt;** (MatchError) no match of right hand side value&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A map pattern will match any map that has all the keys specified in the pattern. The values for the matching keys must also match. For example, &lt;code&gt;%{&amp;quot;hello&amp;quot; =&amp;gt; world}&lt;/code&gt; will match any map that has the key &lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt; and assign the value to &lt;code&gt;world&lt;/code&gt;, while &lt;code&gt;%{&amp;quot;hello&amp;quot; =&amp;gt; &amp;quot;world&amp;quot;}&lt;/code&gt; will match any map that has the key &lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt; with value equals to &lt;code&gt;&amp;quot;world&amp;quot;&lt;/code&gt;. An empty map pattern (&lt;code&gt;%{}&lt;/code&gt;) will match all maps.&lt;/p&gt;

&lt;p&gt;Developers can use the functions in the &lt;a href="/docs/stable/elixir/#!Map.html"&gt;&lt;code&gt;Map&lt;/code&gt; module&lt;/a&gt; to work with maps. For more information on maps and how they compare to other associative data structures in the language, please check the &lt;a href="/getting-started/maps-and-dicts.html"&gt;Maps chapter in our new Getting Started guide&lt;/a&gt;. Elixir Sips has also released two episodes that cover maps (&lt;a href="http://elixirsips.com/episodes/054_maps_part_1.html"&gt;part 1&lt;/a&gt; and &lt;a href="http://elixirsips.com/episodes/055_maps_part_2.html"&gt;part 2&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Maps also provide special syntax for creating, accessing and updating maps with atom keys:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-iex" data-lang="iex"&gt;&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;%{&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;john&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;age&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;27&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="go"&gt;%{name: &amp;quot;john&amp;quot;, age: 27}&lt;/span&gt;
&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;
&lt;span class="go"&gt;&amp;quot;john&amp;quot;&lt;/span&gt;
&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;%{&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;meg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="go"&gt;%{name: &amp;quot;meg&amp;quot;, age: 27}&lt;/span&gt;
&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;
&lt;span class="go"&gt;&amp;quot;meg&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Both access and update syntax above expect the given keys to exist. Trying to access or update a key that does not exist raises an error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-iex" data-lang="iex"&gt;&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="p"&gt;%{&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="ss"&gt;address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="gr"&gt;** (ArgumentError) argument error&lt;/span&gt;
&lt;span class="gr"&gt;     :maps.update(:address, [], %{})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As we will see, this functionality becomes very useful when working with structs.&lt;/p&gt;

&lt;h2 id="structs"&gt;Structs&lt;/h2&gt;

&lt;p&gt;Structs are meant to replace Elixir records. Records in Elixir are simply tuples supported by modules which store record metadata:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="n"&gt;defrecord&lt;/span&gt; &lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;age&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Internally, this record is represented as the following tuple:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="c1"&gt;# {tag, name, age}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Records can also be created and pattern matched on:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-iex" data-lang="iex"&gt;&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;john&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="go"&gt;User[name: &amp;quot;john&amp;quot;, age: 0]&lt;/span&gt;
&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;
&lt;span class="go"&gt;&amp;quot;john&amp;quot;&lt;/span&gt;
&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt;
&lt;span class="go"&gt;User[name: &amp;quot;john&amp;quot;, age: 0]&lt;/span&gt;
&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;
&lt;span class="go"&gt;&amp;quot;john&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pattern matching works because the record meta-data is stored in the User module which can be accessed when building patterns.&lt;/p&gt;

&lt;p&gt;However, records came with their own issues. First of all, since records were made of data (the underlying tuple) and a module (functions/behaviour), they were frequently misused as an attempt to bundle data and behaviour together in Elixir, for example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="n"&gt;defrecord&lt;/span&gt; &lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;age&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;first_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;String&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;at&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;john doe&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;first_name&lt;/span&gt; &lt;span class="c1"&gt;#=&amp;gt; &amp;quot;john&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not only that, records were often slow in protocol dispatches because every tuple can potentially be a record, sometimes leading to expensive checks at runtime.&lt;/p&gt;

&lt;p&gt;Since maps are meant to replace many cases of records in Erlang, we saw with the introduction of maps the perfect opportunity to revisit Elixir records as well. In order to understand the reasoning behind structs, let&amp;#39;s list the features we got from Elixir records:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A way to organize data by fields&lt;/li&gt;
&lt;li&gt;Efficient in-memory representation and operations&lt;/li&gt;
&lt;li&gt;Compile-time structures with compile-time errors&lt;/li&gt;
&lt;li&gt;The basic foundation for polymorphism in Elixir&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Maps naturally solve issues &lt;code&gt;1.&lt;/code&gt; and &lt;code&gt;2.&lt;/code&gt; above. In particular, maps that have same keys share the same key-space in memory. That&amp;#39;s why the update operation &lt;code&gt;%{map | ...}&lt;/code&gt; we have seen above is relevant: if we know we are updating an existing key, the new map created as result of the update operation can share the same key space as the old map without extra checks. For more details on why Maps are efficient, I would recommend &lt;a href="http://joearms.github.io/2014/02/01/big-changes-to-erlang.html"&gt;reading Joe&amp;#39;s blog post on the matter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Structs were added to address features &lt;code&gt;3.&lt;/code&gt; and &lt;code&gt;4.&lt;/code&gt;. A struct needs to be explicitly defined via &lt;code&gt;defstruct&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmodule&lt;/span&gt; &lt;span class="nc"&gt;User&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kd"&gt;defstruct&lt;/span&gt; &lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;age&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now a &lt;code&gt;User&lt;/code&gt; struct can be created without a need to explicitly list all necessary fields:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-iex" data-lang="iex"&gt;&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;john&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="go"&gt;%User{name: &amp;quot;john&amp;quot;, age: 0}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Trying to create a struct with an unknown key raises an error during compilation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-iex" data-lang="iex"&gt;&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;%&lt;/span&gt;&lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[]}&lt;/span&gt;
&lt;span class="gr"&gt;** (CompileError) unknown key :address for struct User&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Furthermore, every struct has a &lt;code&gt;__struct__&lt;/code&gt; field which contains the struct name:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-iex" data-lang="iex"&gt;&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__struct__&lt;/span&gt;
&lt;span class="go"&ggt;User&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;__struct__&lt;/code&gt; field is also used for polymorphic dispatch in protocols, addressing issue &lt;code&gt;4.&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It is interesting to note that structs solve both drawbacks we have earlier mentioned regarding records. Structs are purely data and polymorphic dispatch is now faster and more robust as it happens only for explicitly tagged structs.&lt;/p&gt;

&lt;p&gt;For more information on structs, check out the &lt;a href="/getting-started/structs.html"&gt;Structs chapter in the getting started guide&lt;/a&gt; (you may also want to read the new &lt;a href="/getting-started/protocols.html"&gt;Protocols chapter&lt;/a&gt; after it).&lt;/p&gt;

&lt;h2 id="maps-structs-and-the-future"&gt;Maps, structs and the future&lt;/h2&gt;

&lt;p&gt;With the introduction of maps and structs, some deprecations will arrive on upcoming releases. First of all, the &lt;code&gt;ListDict&lt;/code&gt; data structure is being deprecated and phased out. Records are also being deprecated from the language, although it is going to be a longer process, as many projects and Elixir itself still use records in diverse occasions.&lt;/p&gt;

&lt;p&gt;Note though only Elixir records are being deprecated. Erlang records, which are basically syntax sugar around tuples, will remain in the language for the rare cases Elixir developers need to interact with Erlang libraries that provide records. In particular, the &lt;a href="/docs/stable/elixir/#!Record.html"&gt;Record&lt;/a&gt; has been updated to provide the new Record API (while keeping the old one for backwards compatibility).&lt;/p&gt;

&lt;p&gt;Finally, structs are still in active development and new features, like &lt;code&gt;@derive&lt;/code&gt;, should land in upcoming Elixir releases. For those interested, the &lt;a href="https://gist.github.com/josevalim/b30c881df36801611d13"&gt;original maps and structs proposal is still availble&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="comprehensions"&gt;Comprehensions&lt;/h2&gt;

&lt;p&gt;Erlang R17 also introduced recursion to anonymous functions. This feature, while still not available from Elixir, allows Elixir to provide a more flexible and extensible comprehension syntax.&lt;/p&gt;

&lt;p&gt;The most common use case of a comprehension are &lt;a href="https://en.wikipedia.org/wiki/List_comprehension"&gt;list comprehensions&lt;/a&gt;. For example, we can get all the square values of elements in a list as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-iex" data-lang="iex"&gt;&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
&lt;span class="go"&gt;[1, 4, 9, 16]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We say the &lt;code&gt;n &amp;lt;- [1, 2, 3, 4]&lt;/code&gt; part is a comprehension generator. In previous Elixir versions, Elixir supported only lists in generators. In Elixir v0.13.0, any Enumerable is supported (ranges, maps, etc):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-iex" data-lang="iex"&gt;&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
&lt;span class="go"&gt;[1, 4, 9, 16]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As in previous Elixir versions, there is also support for a bitstring generator. In the example below, we receive a stream of RGB pixels as a binary and break it down into triplets:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-iex" data-lang="iex"&gt;&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;pixels&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;213&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;132&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;76&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;76&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;234&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;pixels&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;gt;,&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="go"&gt;[{213,45,132}, {64,76,32}, {76,0,0}, {234,32,15}]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By default, a comprehension returns a list as a result. However the result of a comprehension can be inserted into different data structures by passing the &lt;code&gt;:into&lt;/code&gt; option. For example, we can use bitstring generators with the &lt;code&gt;:into&lt;/code&gt; option to easily remove all spaces in a string:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-iex" data-lang="iex"&gt;&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; hello world &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;?&lt;/span&gt;&lt;span class="se"&gt;\s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;into&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;&amp;quot;helloworld&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Sets, maps and other dictionaries can also be given with the &lt;code&gt;:into&lt;/code&gt; option. In general, the &lt;code&gt;:into&lt;/code&gt; accepts any structure as long as it implements the &lt;a href="/docs/stable/elixir/#!Collectable.html"&gt;&lt;code&gt;Collectable&lt;/code&gt; protocol&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For example, the &lt;code&gt;IO&lt;/code&gt; module provides streams, that are both &lt;code&gt;Enumerable&lt;/code&gt; and &lt;code&gt;Collectable&lt;/code&gt;. You can implement an echo terminal that returns whatever is typed into the shell, but in upcase, using comprehensions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-iex" data-lang="iex"&gt;&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;IO&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:stdio&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;iex&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;into&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="gp"&gt;...&amp;gt; &lt;/span&gt;  &lt;span class="nc"&gt;String&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;upcase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="gp"&gt;...&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This makes comprehensions useful not only for working with in-memory collections but also with files, io devices, and other sources. In future releases, we will continue exploring how to make comprehensions more expressive, following in the footsteps of other functional programming research on the topic (like Comprehensive Comprehensions and Parallel Comprehensions).&lt;/p&gt;

&lt;h2 id="mix-workflows"&gt;Mix workflows&lt;/h2&gt;

&lt;p&gt;The last big change we want to discuss in this release are the improvements done to Mix, Elixir&amp;#39;s build tool. Mix is an essential tool to Elixir developers and helps developers to compile their projects, manage their dependencies, run tests and so on. &lt;/p&gt;

&lt;p&gt;In previous releases, Mix was used to download and compile dependencies per environment. That meant the usual workflow was less than ideal: every time a dependency was updated, developers had to explicitly fetch and compile the dependencies for each environment. The workflow would be something like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;mix deps.get
&lt;span class="nv"&gt;$ &lt;/span&gt;mix compile
&lt;span class="nv"&gt;$ MIX_ENV&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;test &lt;/span&gt;mix deps.get
&lt;span class="nv"&gt;$ &lt;/span&gt;mix &lt;span class="nb"&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Elixir v0.13, &lt;code&gt;mix deps.get&lt;/code&gt; only fetches dependencies and it does so accross all environments (unless an &lt;code&gt;--only&lt;/code&gt; flag is specified). To support this new behaviour, dependencies now support the &lt;code&gt;:only&lt;/code&gt; option:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;deps&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="ss"&gt;:ecto&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;github&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;elixir-lang/ecto&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:hackney&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;github&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;benoitc/hackney&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;only&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:test&lt;/span&gt;&lt;span class="p"&gt;]}]&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Dependencies now are also automatically compiled before you run a command. For example, &lt;code&gt;mix compile&lt;/code&gt; will automatically compile pending dependencies for the current environment. &lt;code&gt;mix test&lt;/code&gt; will do the same for test dependencies and so on, interrupting less the developer workflow.&lt;/p&gt;

&lt;h2 id="hex-pm"&gt;hex.pm&lt;/h2&gt;

&lt;p&gt;This release also marks the announcement of &lt;a href="http://hex.pm/"&gt;hex.pm&lt;/a&gt;, a package manager for the Erlang VM. Hex allows you to package and publish your projects while fetching them and performing dependency resolution in your applications.&lt;/p&gt;

&lt;p&gt;Currently Hex only integrates with Mix and contributions to extend it to other tools and other languages in the Erlang VM are welcome!&lt;/p&gt;

&lt;h2 id="the-next-steps"&gt;The next steps&lt;/h2&gt;

&lt;p&gt;As seen in this announcement, this release dictates many of the developments that will happen in Elixir and its community in the following weeks. All projects are recommended to start moving from records to structs, paving the way for the deprecation of records before 1.0.&lt;/p&gt;

&lt;p&gt;The next months will also focus on integrating Elixir more tightly to OTP. During the keynote at Erlang Factory, &lt;a href="http://www.youtube.com/watch?v=Djv4C9H9yz4"&gt;Catalyse Change&lt;/a&gt;, Dave Thomas and I argued that there are many useful patterns, re-implemented everyday by developers, that could make development more productive within the Erlang VM if exposed accordingly.&lt;/p&gt;

&lt;p&gt;That said, in the next months we plan to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Integrate applications configuration (provided by OTP) right into Mix;&lt;/li&gt;
&lt;li&gt;Provide an Elixir logger that knows how to print and format Elixir exceptions and stacktraces;&lt;/li&gt;
&lt;li&gt;Properly expose the functionality provided by Applications, Supervisors, GenServers and GenEvents and study how they can integrate with Elixir. For example, how to consume events from GenEvent as a &lt;a href="/docs/stable/elixir/#!Stream.html"&gt;stream of data&lt;/a&gt;?&lt;/li&gt;
&lt;li&gt;Study how patterns like tasks and agents can be integrated into the language, often picking up the lessons learned by libraries like &lt;a href="http://e2project.org/erlang.html"&gt;e2&lt;/a&gt; and &lt;a href="http://erlang.org/doc/man/rpc.html"&gt;functionality exposed by OTP itself&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;Rewrite the Mix and ExUnit guides to focus on applications and OTP as a whole, rebranding it to &amp;quot;Building Apps with Mix and OTP&amp;quot;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can learn more about Elixir in our &lt;a href="/getting-started/introduction.html"&gt;Getting Started guide&lt;/a&gt; and download this release in the &lt;a href="https://github.com/elixir-lang/elixir/releases/tag/v0.13.0"&gt;v0.13 announcement&lt;/a&gt;. We hope to see you at &lt;a href="http://elixirconf.com/"&gt;ElixirConf&lt;/a&gt; as well as pushing your packages to &lt;a href="http://hex.pm/"&gt;hex.pm&lt;/a&gt;.&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.12.0 released</title>
  <link href="http://elixir-lang.org/blog/2013/12/15/elixir-v0-12-0-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2013-12-15T00:00:00+00:00</updated>
  <id>/blog/2013/12/15/elixir-v0-12-0-released</id>
  <content type="html">&lt;p&gt;Elixir v0.12.0 has been released with improved enumerables, build patterns and welcoming a new member to our team.&lt;/p&gt;

&lt;h2 id="enumerables"&gt;Enumerables&lt;/h2&gt;

&lt;p&gt;In previous versions, the Enumerable protocol was based on reduce/fold, and while it is very efficient for operations like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt;, it was sub-optimal for operations that need to halt, like &lt;code&gt;take&lt;/code&gt; and &lt;code&gt;take_while&lt;/code&gt;, and it made it impossible for operations like &lt;code&gt;zip&lt;/code&gt; to be implemented. &lt;/p&gt;

&lt;p&gt;In v0.12.0, Elixir&amp;#39;s Enumerable protocol has been extended to allow suspension and halting mechanisms, making operations like &lt;code&gt;take&lt;/code&gt; simpler and operations that require interleaving, like &lt;code&gt;zip&lt;/code&gt;, possible.&lt;/p&gt;

&lt;p&gt;Although most users don&amp;#39;t need to concern with the implementation of the Enumerable protocol, the side-effect is that both &lt;code&gt;Enum&lt;/code&gt; and &lt;code&gt;Stream&lt;/code&gt; modules have been considerably extended and improved in this release, with more than 15 new functions added to the &lt;code&gt;Stream&lt;/code&gt; module.&lt;/p&gt;

&lt;h2 id="mix"&gt;Mix&lt;/h2&gt;

&lt;p&gt;The tool that received most improvements in this release was Mix. The biggest change is that Mix no longer compiles projects in place but to the &lt;code&gt;_build&lt;/code&gt; directory. For example, take the &lt;a href="https://github.com/elixir-lang/ecto"&gt;Ecto project&lt;/a&gt; that &lt;a href="https://github.com/elixir-lang/ecto/blob/master/mix.exs#L24-L25"&gt;depends on &lt;code&gt;postgrex&lt;/code&gt; and &lt;code&gt;poolboy&lt;/code&gt;&lt;/a&gt;. When compiled, all the artifacts will be placed in the &lt;code&gt;_build&lt;/code&gt; directory like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;_build
└── shared
    └── lib
        ├── ecto
        │   └── ebin
        |   └── priv
        ├── poolboy
        │   └── ebin
        └── postgrex
            └── ebin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For those familiar with Erlang&amp;#39;s OTP, this is similar to the structure used by OTP when releasing your software. So this new structure makes our software one step close to production and guarantee it is designed correctly since day 1.&lt;/p&gt;

&lt;p&gt;This approach comes with the &lt;code&gt;:build_per_environment&lt;/code&gt; option which, when set to true, creates a different build per environment (&lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt;, &lt;code&gt;production&lt;/code&gt; or more). Extremely useful when a project compile different artifacts depending on the compilation environment.&lt;/p&gt;

&lt;p&gt;Mix has also added support to optional dependencies and improved common patterns, like the usage of umbrella apps.&lt;/p&gt;

&lt;h2 id="welcome-eric"&gt;Welcome, Eric!&lt;/h2&gt;

&lt;p&gt;With this release, we also want to welcome &lt;a href="https://github.com/ericmj"&gt;Eric MJ&lt;/a&gt; to the Elixir Team. He has done fantastic work on Elixir, helping us maintain the codebase and working on many of the important features from previous releases and now many more to come.&lt;/p&gt;

&lt;p&gt;Eric is also maintainer of both &lt;a href="https://github.com/elixir-lang/ecto"&gt;Ecto&lt;/a&gt; and &lt;a href="https://github.com/ericmj/postgrex"&gt;Postgrex&lt;/a&gt; projects. Which are proving to be very useful to the Elixir community too!&lt;/p&gt;

&lt;h2 id="tidying-up"&gt;Tidying up&lt;/h2&gt;

&lt;p&gt;There were other small changes, like additions to the &lt;code&gt;Float&lt;/code&gt; module and improvements the to the typespec syntax. To see the full list, please &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.12.0/CHANGELOG.md"&gt;see the CHANGELOG&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Give Elixir a try! You can start with our &lt;a href="/getting-started/introduction.html"&gt;getting started guide&lt;/a&gt;, or check out our sidebar for other learning resources.&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir's new continuable enumerators</title>
  <link href="http://elixir-lang.org/blog/2013/12/11/elixir-s-new-continuable-enumerators/" />
  
  <author>
    <name>Peter Minten</name>
  </author>
  
  <updated>2013-12-11T00:00:00+00:00</updated>
  <id>/blog/2013/12/11/elixir-s-new-continuable-enumerators</id>
  <content type="html">&lt;p&gt;As you may have heard in the upcoming 0.12.0 release Elixir&amp;#39;s enumerators gained
some new features. In this blog post I&amp;#39;ll explain what&amp;#39;s new, what it enables
and how it works.&lt;/p&gt;

&lt;p&gt;For those of you who use the development version of Elixir these changes are
already available. For the exact differences in code you can look at the
&lt;a href="https://github.com/elixir-lang/elixir/pull/1922"&gt;relevant pull request&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="a-recap-of-enumerators-and-some-terminology"&gt;A recap of enumerators, and some terminology&lt;/h2&gt;

&lt;p&gt;The basic idea of enumerators is that you traverse some data structure or
resource (lines from a file) by putting the thing that is traversed in control.
That is if you&amp;#39;re reading from a file you have a loop that reads lines from a
file and for each line calls a function. Just calling a function isn&amp;#39;t all that
useful for most tasks as there&amp;#39;d be no way to remember previous lines (ugly
hacks aside), so some accumulator value is passed to the function and a new
accumulator is returned by it.&lt;/p&gt;

&lt;p&gt;For example here&amp;#39;s how you can count the total length of strings in a list.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="nc"&gt;Enumerable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;String&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Often the actual call to &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; is hidden inside another
function.  Say that we want to define a &lt;code&gt;sum&lt;/code&gt; function. The usual way is to
write it like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coll&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="nc"&gt;Enumerable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coll&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This could get called as &lt;code&gt;Enum.map(1..10, &amp;amp;(&amp;amp;1 * &amp;amp;1)) |&amp;gt; sum()&lt;/code&gt; to get the sum of
squares. Desugaring this means &lt;code&gt;sum(Enum.map(1..10, &amp;amp;(&amp;amp;1 * &amp;amp;1)))&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The general pattern is this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;outer_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coll&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="p"&gt;...&lt;/span&gt;
  &lt;span class="nc"&gt;Enumerable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;coll&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;initial_consumer_acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;something_that_returns_an_enumerable&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;outer_function&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You&amp;#39;ll notice the slightly uncommon terminology of &amp;quot;outer function&amp;quot; and
&amp;quot;consumer&amp;quot; (normally called an &amp;quot;iteratee&amp;quot;). That&amp;#39;s intentional, naming an
iteratee a consumer better reflects that it consumes values.&lt;/p&gt;

&lt;p&gt;Along the same lines I call the reduce function for a specific enumerable a
producer, it produces values which are given to a consumer.&lt;/p&gt;

&lt;p&gt;The outer function is the function to which the enumerable is passed.
Syntactically it looks like this is the consumer, but it&amp;#39;s really a function
that combines the producer and the consumer. For simple consumers (say &lt;code&gt;fn x,
acc -&amp;gt; length(x) + acc end&lt;/code&gt;) the consumer will often be written directly in the
source text of the outer function, but let&amp;#39;s try to keep those concepts
distinguished.&lt;/p&gt;

&lt;h2 id="two-issues-with-classic-elixir-enumerators"&gt;Two issues with classic Elixir enumerators&lt;/h2&gt;

&lt;p&gt;Enumerators are great, but they have their limitations. One issue is that it&amp;#39;s
not possible to define a function that only returns at most 3 elements without
traversing all elements or using ugly tricks such as &lt;code&gt;throw&lt;/code&gt; (with a
&lt;code&gt;try...catch&lt;/code&gt; construct in the outer function). The &lt;code&gt;throw&lt;/code&gt; trick is used in
&lt;code&gt;Enum&lt;/code&gt; and &lt;code&gt;Stream&lt;/code&gt; to implement functions such as &lt;code&gt;Enum.take/2&lt;/code&gt; and
&lt;code&gt;Stream.take_while/2&lt;/code&gt;. It works, but it&amp;#39;s not what I&amp;#39;d call stylish.&lt;/p&gt;

&lt;p&gt;A bigger problem, that doesn&amp;#39;t have a workaround, is that there&amp;#39;s no way to
interleave two enumerables. That is, it&amp;#39;s not possible to define a function that
for two enumerables &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; returns a list &lt;code&gt;[A1, B1, A2, B2, A3, ...]&lt;/code&gt;
(where &lt;code&gt;A1&lt;/code&gt; is the first element of A) without first traversing both lists and
then interleaving the collected values. Interleaving is important because it&amp;#39;s
the basis of a zip function. Without interleaving you cannot implement
&lt;code&gt;Stream.zip/2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The underlying problem, in both cases, is that the producer is fully in control.
The producer simply pushes out as many elements to the consumer as it wants and
then says &amp;quot;I&amp;#39;m done&amp;quot;. There&amp;#39;s no way aside from &lt;code&gt;throw/raise&lt;/code&gt; for a consumer
to tell a producer &amp;quot;stop producing&amp;quot;. There is definitely no way to tell a
producer &amp;quot;stop for now but be prepared to continue where you left off later&amp;quot;.&lt;/p&gt;

&lt;h2 id="power-to-the-consumer"&gt;Power to the consumer!&lt;/h2&gt;

&lt;p&gt;At CodeMeshIO José Valim and Jessica Kerr sat down and discussed this problem.
They came up with a solution inspired by a &lt;a href="http://themonadreader.files.wordpress.com/2010/05/issue16.pdf"&gt;Monad.Reader
article&lt;/a&gt; (third
article). It&amp;#39;s an elegant extension of the old system, based on a simple idea.
Instead of returning only an accumulator at every step (for every produced
value) the consumer returns a combination of an accumulator and an instruction
to the producer. Three instructions are available:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:cont&lt;/code&gt; - Keep producing.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:halt&lt;/code&gt; - Stop producing.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:suspend&lt;/code&gt; - Temporarily stop producing.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A consumer that always returns &lt;code&gt;:cont&lt;/code&gt; makes the producer behave exactly the
same as in the old system. A consumer may return &lt;code&gt;:halt&lt;/code&gt; to have the producer
terminate earlier than it normally would.&lt;/p&gt;

&lt;p&gt;The real magic is in &lt;code&gt;:suspend&lt;/code&gt; though. It tells a producer to return the
accumulator and a continuation function. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:suspended&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cont&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Enumerable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:cont&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:suspend&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:cont&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&llt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After running this code &lt;code&gt;n_&lt;/code&gt; will be &lt;code&gt;3&lt;/code&gt; (1 + 2) and &lt;code&gt;cont&lt;/code&gt; will be a
function. We&amp;#39;ll get back to &lt;code&gt;cont&lt;/code&gt; in a minute but first take a look at some of
the new elements here. The initial accumulator has an instruction as well, so
you could suspend or halt a producer immediately, if you really want to. The
value passed to the consumer (&lt;code&gt;n&lt;/code&gt;) does not contain the instruction. The return
value of the producer also has a symbol in it. Like with the instructions of
consumers there are three possible values:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:done&lt;/code&gt; - Completed normally.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:halted&lt;/code&gt; - Consumer returned a &lt;code&gt;:halt&lt;/code&gt; instruction.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:suspended&lt;/code&gt; - Consumer return a &lt;code&gt;:suspend&lt;/code&gt; instruction.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Together with the other values returned the possible return values from a
producer are &lt;code&gt;{ :done, acc } | { :halted, acc } | { :suspended, acc,
continuation }&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Back to the continuation. A continuation is a function that given an accumulator
returns a new producer result. In other words it&amp;#39;s a way to swap out the
accumulator but keep the same producer in the same state.&lt;/p&gt;

&lt;h2 id="implementing-interleave"&gt;Implementing &lt;code&gt;interleave&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Using the power of suspension it is now possible to create an interleave
function.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmodule&lt;/span&gt; &lt;span class="nc"&gt;Interleave&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;step&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:suspend&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="n"&gt;af&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nc"&gt;Enumerable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ni"&gt;&amp;amp;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;bf&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nc"&gt;Enumerable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ni"&gt;&amp;amp;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;do_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;af&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="ss"&gt;:lists&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="kd"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;do_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.({&lt;/span&gt; &lt;span class="ss"&gt;:cont&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:suspended&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.({&lt;/span&gt; &lt;span class="ss"&gt;:cont&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
          &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:suspended&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class="n"&gt;do_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:halted&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class="n"&gt;acc&lt;/span&gt;
          &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:done&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class="n"&gt;finish_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:halted&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="n"&gt;acc&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:done&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="n"&gt;finish_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="kd"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;finish_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a_or_b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;a_or_b&lt;/span&gt;&lt;span class="p"&gt;.({&lt;/span&gt; &lt;span class="ss"&gt;:cont&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:suspended&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a_or_b&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="n"&gt;finish_interleave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a_or_b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="bp"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="n"&gt;acc&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="nc"&gt;Interleave&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;interleave&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:d&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [1, :a, 2, :b, :c, :d]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lets go through this step by step. The main &lt;code&gt;interleave&lt;/code&gt; function first
partially applies &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; to get function values that work just
like the continuations. This makes things easier for &lt;code&gt;do_interleave&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;do_interleave&lt;/code&gt; function first calls &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;af&lt;/code&gt; from &lt;code&gt;interleave&lt;/code&gt;) with the
&lt;code&gt;step&lt;/code&gt; function so that the available element of &lt;code&gt;a&lt;/code&gt; gets added to the
accumulator and &lt;code&gt;a&lt;/code&gt; immediately suspends afterwards. Then the same is done for
&lt;code&gt;b&lt;/code&gt;. If either producer is done all the remaining elements of the other get
added to the accumulator list.&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;acc&lt;/code&gt; is sometimes used to mean a tuple like &lt;code&gt;{ :cont, x }&lt;/code&gt; and
sometimes the accumulator value proper. It&amp;#39;s a bit confusing, yes.&lt;/p&gt;

&lt;p&gt;This example shows that through clever combination of an outer function
(&lt;code&gt;do_interleave&lt;/code&gt;) and an inner function &lt;code&gt;step&lt;/code&gt; two producers can be interleaved.&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The new system of enumerators certainly makes things a bit more complicated but
also adds power. I suspect many interesting and &amp;quot;interesting&amp;quot; functions can be
built on top of it.&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.11.0 released</title>
  <link href="http://elixir-lang.org/blog/2013/11/05/elixir-v0-11-0-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2013-11-05T00:00:00+00:00</updated>
  <id>/blog/2013/11/05/elixir-v0-11-0-released</id>
  <content type="html">&lt;p&gt;After 4 months, Elixir v0.11.0 has been released with 832 commits since the previous minor release, done by more than 40 contributors. Although we have some great features in this release, the major focus in those 4 months was improving the common patterns used by the community and streamlining the existing workflows.&lt;/p&gt;

&lt;h2 id="iex"&gt;IEx&lt;/h2&gt;

&lt;p&gt;One of the tools that most received improvements in this release was our interactive shell. Such improvements come as no surprise as Elixir developers spend a good amount of time in the shell, which is great for development, allowing you to quickly try and load code, to production, where IEx can connect to remote nodes to inspect production information.&lt;/p&gt;

&lt;p&gt;The IEx helper &lt;code&gt;h&lt;/code&gt;, responsible for showing documentation for existing modules and functions, has now been improved to rely on ANSI codes and nicely format the documentation. let&amp;#39;s take a look at the docs for the String module:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/string-help.png" alt="String module docs"&gt;&lt;/p&gt;

&lt;p&gt;This change goes in line with Elixir&amp;#39;s goal of providing first-class documentation, which makes documentation easily accessible at runtime, support to doctests and more.&lt;/p&gt;

&lt;p&gt;In this new release, IEx also supports a very simple debugging mechanism called &lt;code&gt;IEx.pry&lt;/code&gt;. Let&amp;#39;s see an screenshot of it in action:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/iex-pry.png" alt="IEx pry example"&gt;&lt;/p&gt;

&lt;p&gt;In Elixir, your code runs in many processes that talk to each other and the Elixir shell is no different. &lt;code&gt;IEx.pry&lt;/code&gt; allows another process to take over the shell, allowing the developer to inspect the binding and halt the execution of the process being &amp;quot;pried&amp;quot; (i.e. the one that invoked &lt;code&gt;IEx.pry&lt;/code&gt;). We called this feature &lt;code&gt;pry&lt;/code&gt; as a gentle reminder that you can only inspect existing information, you cannot change the binding over a pried process. For more information, check the docs for &lt;a href="/docs/stable/iex/#!IEx.html#pry/1"&gt;&lt;code&gt;IEx.pry/1&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="exunit"&gt;ExUnit&lt;/h2&gt;

&lt;p&gt;&lt;a href="/blog/2013/07/13/elixir-v0-10-0-released/"&gt;In the previous release&lt;/a&gt;, we introduced great changes to ExUnit, like the support for the &lt;code&gt;--trace&lt;/code&gt; option. This time we continued pushing improvements, like adding profiling to test cases (times can be seen with the &lt;code&gt;--trace&lt;/code&gt; option), paving the way for other features like emitting warnings for test cases that are too slow.&lt;/p&gt;

&lt;p&gt;Another simple but significant change in ExUnit was the change in the default formatter to print changes as they come, instead of waiting until the suite is done running:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/fast-fail.png" alt="ExUnit Fast Fail"&gt;&lt;/p&gt;

&lt;p&gt;This change allows developer to get faster feedback from their test suites.&lt;/p&gt;

&lt;h2 id="mix"&gt;Mix&lt;/h2&gt;

&lt;p&gt;Since the early days, Elixir took ahold of the compilation process in order to provide a seamless compilation experience. &lt;a href="/blog/2012/04/24/a-peek-inside-elixir-s-parallel-compiler/"&gt;Elixir&amp;#39;s ParallelCompiler&lt;/a&gt; was introduced even before the first official release, allowing developers to harness all the cores in their computer to compile Elixir code. However, once the first release came out, every time you changed any file, the whole project had to be recompiled.&lt;/p&gt;

&lt;p&gt;In the past releases we have improved this process to only compile files that changed and their dependencies. For v0.11.0, we have improved this process to be faster and less conservative than the previous version.&lt;/p&gt;

&lt;p&gt;Mix has also improved support for umbrella projects, which are projects that contain multiple OTP applications, essential for building large projects. The current release allows sharing of dependencies between projects and faster and dependency resolution times.&lt;/p&gt;

&lt;h2 id="other-changes"&gt;Other changes&lt;/h2&gt;

&lt;p&gt;This release also introduces the new capture operator, which provides a convenient syntax for retrieving functions so they can be passed as arguments:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="nc"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;all?&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="ss"&gt;:foo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:bar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:baz&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;is_atom&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which can also be used for partially applying functions and macros:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;is_record&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ni"&gt;&amp;amp;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;.(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can learn more about the &lt;a href="/docs/stable/elixir/#!Kernel.SpecialForms.html#&amp;amp;/1"&gt;new capture operator in our docs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We have also pushed improvements to &lt;a href="/docs/stable/elixir/#!String.html"&gt;the String module&lt;/a&gt;, including new APIs. In particular, in order to know that &lt;code&gt;String.length(&amp;quot;josé&amp;quot;)&lt;/code&gt; has length 4 (even though it takes 5 bytes to be represented in UTF-8), we need to use some algorithms defined by the Unicode Standard. These have been implemented as specified in the &lt;a href="http://www.unicode.org/reports/tr29/"&gt;extended grapheme cluster algorithm, defined in the version 6.3.0 of the Unicode Standard&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the optimization front, we have pushed the first iteration of a &lt;a href="https://groups.google.com/forum/#!topic/elixir-lang-core/RoXAUtoyjk4"&gt;feature called Protocol consolidation&lt;/a&gt;, which speeds up the polymorphic dispatch done by protocols, sometimes reducing the dispatching time to 10% of the original time. We will continue working in upcoming releases to integrate protocol consolidation as a regular part of the developer workflow.&lt;/p&gt;

&lt;p&gt;And finally, a minor but frequently asked feature has finally arrived into Elixir: variables follow the same rules as other identifiers in the language, which means developers can now name their variables &lt;code&gt;is_atom?&lt;/code&gt;. For a general overview, &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.11.0/CHANGELOG.md"&gt;check out the CHANGELOG&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Give Elixir a try! You can start with our &lt;a href="/getting-started/introduction.html"&gt;getting started guide&lt;/a&gt;, or check out our sidebar for other learning resources.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PS:&lt;/strong&gt; We have just released v0.11.1 which addresses a regression in Mix and improves the dependencies update process.&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir Design Goals</title>
  <link href="http://elixir-lang.org/blog/2013/08/08/elixir-design-goals/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2013-08-08T00:00:00+00:00</updated>
  <id>/blog/2013/08/08/elixir-design-goals</id>
  <content type="html">&lt;p&gt;During the last year, we have spoken at many conferences spreading the word about Elixir. We &lt;a href="http://vimeo.com/53221562"&gt;usually started with introducing the Erlang VM&lt;/a&gt;, then went on to talk about Elixir goals, saving some time at the end to do a live demo, showing some goodies like exchanging information between remote nodes and even hot code swapping.&lt;/p&gt;

&lt;p&gt;This post is a summary of those talks, focusing on the language goals: compatibility, productivity and extensibility.&lt;/p&gt;

&lt;h2 id="compatibility"&gt;Compatibility&lt;/h2&gt;

&lt;p&gt;Elixir is meant to be compatible with the Erlang VM and the existing ecosystem. When we talk about Erlang, we can break it into three parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A functional programming language, called Erlang&lt;/li&gt;
&lt;li&gt;A set of design principles, called OTP&lt;/li&gt;
&lt;li&gt;The Erlang Virtual Machine, referred to as EVM or BEAM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Elixir runs in the same virtual machine and is compatible with OTP. Not only that, all the tools and libraries available in the Erlang ecosystem are also available in Elixir, simply because there is no conversion cost from calling Erlang from Elixir and vice-versa.&lt;/p&gt;

&lt;p&gt;We frequently say that &lt;strong&gt;the Erlang VM is Elixir&amp;#39;s strongest asset&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;All Elixir code is executed inside light-weight processes (actors), each with its own state, that exchange messages between each other. The Erlang VM multiplexes those processes onto many cores, making it trivial to run code concurrently.&lt;/p&gt;

&lt;p&gt;In fact if you compile any Elixir code, including the Elixir source, you will see all cores on your machine being used out of the box. With &lt;a href="http://www.parallella.org/board/"&gt;technologies like Parallella&lt;/a&gt; becoming more accessible and affordable, it is hard to ignore the power you can get out of the Erlang VM.&lt;/p&gt;

&lt;p&gt;Finally, the Erlang VM was designed to build systems that run forever, self-heal and scale. Joe Armstrong, one of Erlang&amp;#39;s creators, has recently given an excellent talk &lt;a href="http://www.infoq.com/presentations/self-heal-scalable-system"&gt;about the design decisions behind OTP and the VM&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Nothing that we are describing here is particularly new. Open source projects like CouchDB, Riak, RabbitMQ, Chef11 and companies like Ericsson, Heroku, Basho, Klarna and Wooga are already enjoying the benefits provided by the Erlang VM, some of them for quite a long time.&lt;/p&gt;

&lt;h2 id="productivity"&gt;Productivity&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Now we need to go meta. We should now think of a language design as being a pattern for language designs. A tool for making more tools of the same kind. [...] A language design can no longer be a thing. It must be a pattern, a pattern for growth. A pattern for growing a pattern, for defining the patterns that programmers can use for their real work and main goals.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Guy Steele, keynote at the 1998 ACM OOPSLA conference on &amp;quot;Growing a Language&amp;quot;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Productivity is, in general, a hard goal to measure. A language productive for creating desktop applications may not be productive for mathematical computing. Productivity depends directly on the field in which you intend to use the language, the available tools in the ecosystem and how easy it is to create and extend those tools.&lt;/p&gt;

&lt;p&gt;For this reason, we have opted for a small language core. For example, while some languages have &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt; and so on as language keywords, each with its own rules in the parser, &lt;strong&gt;in Elixir they are just macros&lt;/strong&gt;. This allows us to implement most of Elixir in Elixir and also allows developers to extend the language using the same tools we used to build the language itself, often extending the language to the specific domains they are working on.&lt;/p&gt;

&lt;p&gt;Here is an example of how someone would implement &lt;code&gt;unless&lt;/code&gt;, which is a keyword in many languages, in Elixir:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmacro&lt;/span&gt; &lt;span class="k"&gt;unless&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="k"&gt;quote&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="k"&gt;unquote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;unquote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="no"&gt;true&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="nc"&gt;IO&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;this will never be seen&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since a macro receives the code representation as arguments, we can simply convert an &lt;code&gt;unless&lt;/code&gt; into an &lt;code&gt;if&lt;/code&gt; at compile time.&lt;/p&gt;

&lt;p&gt;Macros are also the base construct for meta-programming in Elixir: the ability to write code that generates code. Meta-programming allows developers to easily get rid of boilerplate and create powerful tools. A common example mentioned in talks is how our test framework uses macros for expressiveness. Let&amp;#39;s see an example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="nc"&gt;ExUnit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;

&lt;span class="kd"&gt;defmodule&lt;/span&gt; &lt;span class="nc"&gt;MathTest&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="nc"&gt;ExUnit.Case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;async&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;true&lt;/span&gt;

  &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;adding two numbers&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first thing to notice is the &lt;code&gt;async: true&lt;/code&gt; option. When your tests do not have any side-effects, you can run them concurrently by passing the &lt;code&gt;async: true&lt;/code&gt; option.&lt;/p&gt;

&lt;p&gt;Next we define a test case and we do an assertion with the &lt;code&gt;assert&lt;/code&gt; macro. Simply calling &lt;code&gt;assert&lt;/code&gt; would be a bad practice in many languages as it would provide a poor error report. In such languages, functions/methods like &lt;code&gt;assertEqual&lt;/code&gt; or &lt;code&gt;assert_equal&lt;/code&gt; would be the recommended way of performing such assertion.&lt;/p&gt;

&lt;p&gt;In Elixir, however, &lt;code&gt;assert&lt;/code&gt; is a macro and as such it can look into the code being asserted and infer that a comparison is being made. This code is then transformed to provide a detailed error report when the test runs:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;1) test adding two numbers (MathTest)
   ** (ExUnit.ExpectationError)
                expected: 3
     to be equal to (==): 4
   at test.exs:7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This simple example illustrates how a developer can leverage macros to provide a concise but powerful API. Macros have access to the whole compilation environment, being able to check the imported functions, macros, defined variables and more.&lt;/p&gt;

&lt;p&gt;Those examples are just scratching the surface of what can be achieved with macros in Elixir. For example, we are currently using macros to compile routes from a web application into a bunch of patterns that are highly optimizable by the VM, providing an expressive but heavily optimized routing algorithm.&lt;/p&gt;

&lt;p&gt;The macro system also caused a huge impact on the syntax, which we will discuss briefly before moving to the last goal.&lt;/p&gt;

&lt;h3 id="syntax"&gt;Syntax&lt;/h3&gt;

&lt;p&gt;Although syntax is usually one of the first topics that comes up when Elixir is being discussed, it was never a goal to simply provide a different syntax. Since we wanted to provide a macro system, we knew that the macro system would only be sane if we could represent Elixir syntax in terms of Elixir&amp;#39;s own data structures in a straight-forward fashion. With this goal in mind, we set out to design the first Elixir version, which looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmodule&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="kd"&gt;def&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calculate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="p"&gt;=(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the snippet above, we represent everything, except variables, as a function or a macro call. Notice keyword arguments like &lt;code&gt;do:&lt;/code&gt; have been present since the first version. To this, we slowly added new syntax, making some common patterns more elegant while keeping the same underlying data representation. We soon added infix notation for operators:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmodule&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="kd"&gt;def&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;calculate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
  &lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The next step was to make parentheses optional:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmodule&lt;/span&gt; &lt;span class="nc"&gt;Hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;calculate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And finally we added &lt;code&gt;do/end&lt;/code&gt; as convenience for the common &lt;code&gt;do: (...)&lt;/code&gt; construct:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmodule&lt;/span&gt; &lt;span class="nc"&gt;Hello&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;calculate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given my previous background in Ruby, it is natural that some of the constructs added were borrowed from Ruby. However, those additions were a by-product, never a language goal.&lt;/p&gt;

&lt;p&gt;Many language constructs are also inspired by their Erlang counter-parts, like some of the control-flow macros, operators and containers. Notice how some Elixir code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="c1"&gt;# A tuple&lt;/span&gt;
&lt;span class="n"&gt;tuple&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;# Adding two lists&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c1"&gt;# Case&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
  &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="ow"&gt;when&lt;/span&gt; &lt;span class="n"&gt;is_integer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;maps to Erlang:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-erlang" data-lang="erlang"&gt;&lt;span class="c"&gt;% A tuple&lt;/span&gt;
&lt;span class="nv"&gt;Tuple&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;}.&lt;/span&gt;

&lt;span class="c"&gt;% Adding two lists&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;

&lt;span class="c"&gt;% Case&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nv"&gt;Expr&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;Y&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;X&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="nv"&gt;Other&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="nb"&gt;is_integer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;Other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;Other&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="extensibility"&gt;Extensibility&lt;/h2&gt;

&lt;p&gt;By building on top of a small core, most of the constructs in the language can be replaced and extended as required by developers to target specific domains. However, there is a particular domain that Elixir is inherently good at, which is building concurrent, distributed applications, thanks to OTP and the Erlang VM.&lt;/p&gt;

&lt;p&gt;Elixir complements this domain by providing a standard library with:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Unicode strings and unicode operations&lt;/li&gt;
&lt;li&gt;A powerful unit test framework&lt;/li&gt;
&lt;li&gt;More data structures like ranges, including novel implementations for sets and dictionaries&lt;/li&gt;
&lt;li&gt;Polymorphic records (in contrast to Erlang&amp;#39;s compilation-time only records)&lt;/li&gt;
&lt;li&gt;Strict and lazy enumeration APIs&lt;/li&gt;
&lt;li&gt;Convenience functions for scripting, like working with paths and the filesystem&lt;/li&gt;
&lt;li&gt;A project management tool to compile and test Elixir code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And much more.&lt;/p&gt;

&lt;p&gt;Most of the features above provide their own extensibility mechanisms, too. For example, take the &lt;code&gt;Enum&lt;/code&gt; module. The &lt;code&gt;Enum&lt;/code&gt; module allow us to enumerate the built-in ranges, lists, sets, etc:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nc"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [2,4,6]&lt;/span&gt;

&lt;span class="n"&gt;range&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;..&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="nc"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;range&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [2,4,6]&lt;/span&gt;

&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;HashSet&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nc"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [2,4,6]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not only that, any developer can &lt;strong&gt;extend&lt;/strong&gt; the &lt;code&gt;Enum&lt;/code&gt; module to work with any data type as long as the data type implements &lt;a href="/docs/stable/elixir/#!Enumerable.html"&gt;the &lt;code&gt;Enumerable&lt;/code&gt; protocol&lt;/a&gt; (protocols in Elixir are based on Clojure&amp;#39;s protocol). This is extremely convenient because the developer needs to know only the &lt;code&gt;Enum&lt;/code&gt; API for enumeration, instead of memorizing specific APIs for sets, lists, dicts, etc.&lt;/p&gt;

&lt;p&gt;There are many other protocols exposed by the language, like &lt;a href="/docs/stable/elixir/#!Inspect.html"&gt;the &lt;code&gt;Inspect&lt;/code&gt; protocol&lt;/a&gt; for pretty printing data structures and &lt;a href="/docs/stable/elixir/#!Access.html"&gt;the &lt;code&gt;Access&lt;/code&gt; protocol&lt;/a&gt; for accessing key-value data by key. By being extensible, Elixir ensures developers can work &lt;strong&gt;with&lt;/strong&gt; the language, instead of &lt;strong&gt;against&lt;/strong&gt; the language.&lt;/p&gt;

&lt;h2 id="summing-up"&gt;Summing up&lt;/h2&gt;

&lt;p&gt;The goal of this post was to sumarize the language goals: compatibility, productivity and extensibility. By being compatibile with the Erlang VM, we are providing developers another toolset for building concurrent, distributed and fault-tolerant systems.&lt;/p&gt;

&lt;p&gt;We also hope to have clarified what Elixir brings to the Erlang VM, in particular, meta-programming through macros, polymorphic constructs for extensibility and a data-focused standard library with extensible and consistent APIs for diverse types, including strict and lazy enumeration, unicode handling, a test framework and more.&lt;/p&gt;

&lt;p&gt;Give Elixir a try! You can start with our &lt;a href="/getting-started/introduction.html"&gt;getting started guide&lt;/a&gt;, or check out our sidebar for other learning resources.&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.10.0 released</title>
  <link href="http://elixir-lang.org/blog/2013/07/13/elixir-v0-10-0-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2013-07-13T00:00:00+00:00</updated>
  <id>/blog/2013/07/13/elixir-v0-10-0-released</id>
  <content type="html">&lt;p&gt;Elixir v0.10.0 is released with support for streams, sets and many improvements to the Mix and ExUnit applications.&lt;/p&gt;

&lt;h2 id="streams"&gt;Streams&lt;/h2&gt;

&lt;p&gt;The default mechanism for working with collections in Elixir is the &lt;code&gt;Enum&lt;/code&gt; module. With it, you can map over ranges, lists, sets, dictionaries and any other structure as long as it implements the &lt;code&gt;Enumerable&lt;/code&gt; protocol:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="nc"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [2,4,6]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;Enum&lt;/code&gt; module performs eager evaluation. Consider the following example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;take_while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [2,4]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the example above, we enumerate the items in list once, taking all elements that are less than 3, and then we enumerate the remaining elements again, multiplying them by two. In order to retrieve the final result, we have created one intermediate list. As we add more operations, more intermediate lists will be generated.&lt;/p&gt;

&lt;p&gt;This approach is simple and efficient for the majority of the cases but, when working with large collections, we can generate many, possibly large, intermediate lists affecting performance. That&amp;#39;s one of the problems Streams solve. Let&amp;#39;s rewrite the example above using Streams:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;take_while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; #Stream.Lazy&amp;lt;...&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, instead of getting the result back, we got a Stream. The list elements are yet to be enumerated! We can realize the stream  by calling any of the Enum functions, like &lt;code&gt;Enum.to_list/1&lt;/code&gt;. By doing so the list will be iterated just once avoiding the intermediary representations.&lt;/p&gt;

&lt;p&gt;In a nutshell, Streams are composable, lazy enumerables. Streams are also useful when doing IO or expressing infinite computations. We can retrieve a file as a stream:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stream!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;README.md&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the example above, we got a stream that will enumerate the lines in the file one by one when enumerated. We could further extend the stream above, for example, by rejecting blank lines, and the file will be opened just when its results are actually needed.&lt;/p&gt;

&lt;p&gt;Do you need a random number generator? We got your back:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="nc"&gt;Stream&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;repeatedly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="ss"&gt;:random&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;uniform&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;take&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [0.4435846174457203, 0.7230402056221108, 0.94581636451987]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Stream.repeatedly/1&lt;/code&gt; returns an infinite stream but that&amp;#39;s ok we just need its first three elements. You can learn more about &lt;a href="/docs/stable/elixir/#!Stream.html"&gt;stream and related functions in &lt;code&gt;Stream&lt;/code&gt; module documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="sets"&gt;Sets&lt;/h2&gt;

&lt;p&gt;This release also adds &lt;a href="/docs/stable/elixir/#!Set.html"&gt;the Sets API&lt;/a&gt; to Elixir and a HashSet implementation. The HashSet implementation follows &lt;a href="/blog/2013/01/27/elixir-v0-8-0-released/"&gt;the same design goals as the HashDict implementation&lt;/a&gt; released at the beginning of this year, starting with a compact representation and expanding and contracting as needed.&lt;/p&gt;

&lt;p&gt;This feature was a contribution from &lt;a href="https://github.com/josephwilk"&gt;Joseph Wilk&lt;/a&gt; and he talks about its implementation and provides some benchmarks &lt;a href="http://blog.josephwilk.net/elixir/sets-in-elixir.html"&gt;on his blog&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="pretty-printing"&gt;Pretty printing&lt;/h2&gt;

&lt;p&gt;Another addition to this release is pretty printing. The pretty printing started as an implementation of the &lt;a href="http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf"&gt;Wadler paper&lt;/a&gt; by &lt;a href="https://github.com/manpages"&gt;Jonns Mostovoys&lt;/a&gt; which was then improved by &lt;a href="https://github.com/brunoro"&gt;Gustavo Brunoro&lt;/a&gt; under his Google Summer of Code project as described in &lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200"&gt;Lindig&amp;#39;s &lt;em&gt;Strictly Prettier&lt;/em&gt; paper&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As soon as you upgrade to Elixir v0.10.0 and start IEx, you will get pretty printing for all data structures provided by Elixir. We have also added documentation to the &lt;code&gt;Inspect&lt;/code&gt; module about &lt;a href="/docs/stable/elixir/#!Inspect.html"&gt;adding pretty printing to your own structures&lt;/a&gt; as well as &lt;a href="/docs/stable/elixir/#!Inspect.Algebra.html"&gt;using the document algebra for any other kind of formatting&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="other-improvements"&gt;Other improvements&lt;/h2&gt;

&lt;p&gt;Other notable improvements are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;We have improved Mix to be able to fetch Rebar dependencies, making integration with the existing Erlang ecossystem much easier, thanks to &lt;a href="https://github.com/ericmj"&gt;Eric Meadows-Jonsson&lt;/a&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ExUnit now supports the trace option, enabled via &lt;code&gt;mix test --trace&lt;/code&gt;, which forces tests to run sequentially and print the test names and extra information as it goes;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We are also working hard on Windows support, improving its command-line tools and working towards a green test suite, thanks to &lt;a href="https://github.com/tojans"&gt;Tom Jansens&lt;/a&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Meta-programming in Elixir was also improved by the addition of the &lt;code&gt;binding/0&lt;/code&gt; and &lt;code&gt;binding/1&lt;/code&gt; macros plus the additions of &lt;code&gt;Macro.expand_once/2&lt;/code&gt; and &lt;code&gt;Macro.expand_all/2&lt;/code&gt; to the &lt;a href="/docs/stable/elixir/#!Macro.html"&gt;&lt;code&gt;Macro&lt;/code&gt; module&lt;/a&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are also improvements to typespecs, error messages, many bug fixes and some backwards incompatible changes. We have posted a detailed &lt;a href="https://groups.google.com/forum/?fromgroups#!topic/elixir-lang-talk/ksrefrgK1eY"&gt;upgrade instructions on the mailing list&lt;/a&gt;. For a general overview, &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.10.0/CHANGELOG.md"&gt;check out the CHANGELOG&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Give Elixir a try! You can start with our &lt;a href="/getting-started/introduction.html"&gt;getting started guide&lt;/a&gt;, or check out our sidebar for other learning resources.&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.9.0 released</title>
  <link href="http://elixir-lang.org/blog/2013/05/23/elixir-v0-9-0-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2013-05-23T00:00:00+00:00</updated>
  <id>/blog/2013/05/23/elixir-v0-9-0-released</id>
  <content type="html">&lt;p&gt;While &lt;a href="http://pragprog.com/book/elixir/programming-elixir"&gt;Programming Elixir&lt;/a&gt; was being announced, we have been working on Elixir v0.9.0 which is finally out. This release contains new features, important performance optimizations and bug fixes.&lt;/p&gt;

&lt;p&gt;Elixir v0.9.0 also removes support for Erlang R15 and earlier versions. In case you still need to run Elixir software on R15, we have also released Elixir v0.8.3, which contains many of the enhancements in v0.9.0. Check the &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.9.0/CHANGELOG.md"&gt;CHANGELOG for more details for both releases&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All this work was achieved by our very vibrant community! Over the last month, 17 authors have pushed more than 500 commits, where more than 60 pull requests were merged and more than 80 issues were closed.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s talk about the goodies!&lt;/p&gt;

&lt;h2 id="compilation-time-improvements"&gt;Compilation time improvements&lt;/h2&gt;

&lt;p&gt;We have spent some time improving compilation time. The particular scenario we have worked on was the definition of records:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="n"&gt;defrecord&lt;/span&gt; &lt;span class="nc"&gt;User&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;age&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Records are a good scenario because they are implemented in Elixir, using Elixir macros, and they also define a module underneath, which exercises the Erlang VM compilation stack.&lt;/p&gt;

&lt;p&gt;We have used &lt;a href="http://www.erlang.org/doc/man/fprof.html"&gt;fprof&lt;/a&gt; to identify the bottlenecks and made the compilation stack 35% faster. We have also identified bottlenecks coming from Erlang and &lt;a href="https://github.com/erlang/otp/commit/32b194495f353dde014b00008a630eeff2a71056"&gt;pushed some patches&lt;/a&gt; that should benefit both Elixir and Erlang code.&lt;/p&gt;

&lt;p&gt;A special thanks to &lt;a href="https://github.com/yrashk"&gt;Yurii Rashkovskii&lt;/a&gt; for the data and profiling.&lt;/p&gt;

&lt;h2 id="umbrella-projects"&gt;Umbrella projects&lt;/h2&gt;

&lt;p&gt;In Elixir, an application denotes a component implementing some specific functionality, that can be started and stopped as a unit, and which can be re-used in other systems as well.&lt;/p&gt;

&lt;p&gt;As a project grows, it is recommended to break it apart into smaller, isolated applications and bundle them together. The issue so far was that Elixir did not provide good support for working with many applications at once, and compiling and managing those applications became rather a tedious work.&lt;/p&gt;

&lt;p&gt;Elixir v0.9.0 now supports umbrella projects which can work with many applications at the same time. You can create a new umbrella project with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;mix new my_project --umbrella
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The generated project will have the following structure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;apps/
mix.exs
README.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, inside the &lt;code&gt;apps&lt;/code&gt; directory, you can create as many applications as you want and running &lt;code&gt;mix compile&lt;/code&gt; inside the umbrella project will automatically compile all applications. The &lt;a href="https://github.com/elixir-lang/elixir/issues/667"&gt;original discussion for this feature&lt;/a&gt; contains more details about how it all works.&lt;/p&gt;

&lt;p&gt;A special thanks to &lt;a href="https://github.com/ericmj"&gt;Eric Meadows-Jonsson&lt;/a&gt; for implementing this feature and to &lt;a href="https://github.com/yrashk"&gt;Yurii&lt;/a&gt; for testing it against different edge cases.&lt;/p&gt;

&lt;h2 id="reducers"&gt;Reducers&lt;/h2&gt;

&lt;p&gt;Elixir v0.9.0 changes its main abstraction for enumeration from iterators to reducers. Before Elixir v0.9.0, when you invoked:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="nc"&gt;Enum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; [1, 4, 9]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It asked the &lt;code&gt;Enum.Iterator&lt;/code&gt; protocol for instructions on how to iterate the list &lt;code&gt;[1,2,3]&lt;/code&gt;. This iteration happened by retrieving each item in the list, one by one, until there were no items left.&lt;/p&gt;

&lt;p&gt;This approach posed many problems:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Iterators are very hard to compose;&lt;/li&gt;
&lt;li&gt;Iterators contain state. You need to know, at each moment, what is the next element you have to iterate next. We use functions and their bindings to pass the iteration state around;&lt;/li&gt;
&lt;li&gt;Iterators have the &amp;quot;dangling open resource&amp;quot; problem. Consider that you want to iterate a file with &lt;code&gt;Enum.map/2&lt;/code&gt; as above. If any step during the iteration fails, there is no easy way to notify the resource being iterated  (in this case, the opened file) that iteration failed, so we can&amp;#39;t close the file automatically, leaving it to the user.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reducers solve all of those problems by using a more functional approach. Instead of asking a list to spill its elements out one by one and then working on each element, we now generate a recipe of computations and pass it down to the list which applies those computations on itself.&lt;/p&gt;

&lt;p&gt;Here is how we implement the &lt;code&gt;Enumerable&lt;/code&gt; protocol for lists:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defimpl&lt;/span&gt; &lt;span class="nc"&gt;Enumerable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;for&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;do_reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="kd"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;do_reduce&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;do_reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;.(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="kd"&gt;defp&lt;/span&gt; &lt;span class="n"&gt;do_reduce&lt;/span&gt;&lt;span class="p"&gt;([],&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;acc&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The implementation above works as a simple &lt;code&gt;reduce&lt;/code&gt; function (also called &lt;code&gt;fold&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt; or &lt;code&gt;foldl&lt;/code&gt; in other languages). Here is how it works:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="c1"&gt;# Sum all elements in a list&lt;/span&gt;
&lt;span class="nc"&gt;Enumerable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#=&amp;gt; 6&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;Enum.map/2&lt;/code&gt; we have used above is now implemented in terms of this reducing function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmodule&lt;/span&gt; &lt;span class="nc"&gt;Enum&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collection&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="nc"&gt;Enumerable&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collection&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;.(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;)|&lt;/span&gt;&lt;span class="n"&gt;acc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;reverse&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This approach solves all the problems above:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reducers are composable (notice how we have implemented map on top of reduce by composing functions);&lt;/li&gt;
&lt;li&gt;Reducers are self-contained: there is no need keep state around, which also solves the &amp;quot;dangling open resource&amp;quot; problem. The data type now knows exactly when the iteration starts and when it finishes;&lt;/li&gt;
&lt;li&gt;Reducers do not dictate how a type should be enumerated. This means types like &lt;code&gt;Range&lt;/code&gt; and &lt;code&gt;HashDict&lt;/code&gt; can provide a much faster implementation for Reducers;&lt;/li&gt;
&lt;li&gt;Furthermore, the end result is a cleaner implementation of most of &lt;code&gt;Enum&lt;/code&gt; functions (the &lt;a href="https://github.com/elixir-lang/elixir/pull/1102"&gt;reducers pull request&lt;/a&gt; removes over 500LOC) and better performance!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reducers also opens up room for lazy and parallel enumeration, as &lt;a href="http://clojure.com/blog/2012/05/08/reducers-a-library-and-model-for-collection-processing.html"&gt;the Clojure community has already proven&lt;/a&gt; and something we are looking forward to explore on upcoming releases.&lt;/p&gt;

&lt;p&gt;A special thanks to &lt;a href="https://github.com/ericmj"&gt;Eric Meadows-Jonsson&lt;/a&gt; for implementing this feature!&lt;/p&gt;

&lt;h2 id="other-bits"&gt;Other bits&lt;/h2&gt;

&lt;p&gt;We have also many other smaller improvements:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Our CLI now supports &lt;code&gt;--hidden&lt;/code&gt; and &lt;code&gt;--cookie&lt;/code&gt; flags which are useful for distributed modes;&lt;/li&gt;
&lt;li&gt;Our test framework, ExUnit, is now able to capture all the communication that happens with a registed IO device, like &lt;code&gt;:stdio&lt;/code&gt; and &lt;code&gt;:stderr&lt;/code&gt;, via &lt;a href="/docs/stable/ex_unit/#!ExUnit.CaptureIO.html"&gt;&lt;code&gt;ExUnit.CaptureIO&lt;/code&gt;&lt;/a&gt;. This is very useful for testing how your software reacts to some inputs and what it prints to the terminal;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IEx&lt;/code&gt; now allows files to be imported into the shell with &lt;code&gt;import_file&lt;/code&gt; and also loads &lt;code&gt;~/.iex&lt;/code&gt; on startup for custom configuration;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt; and &lt;code&gt;Dict&lt;/code&gt; modules got more convenience functions that goes from checking unicode character validity to taking values out of a dictionary;&lt;/li&gt;
&lt;li&gt;And many, many more!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A huge thank you to our community for sending bug reports, providing bug fixes and contributing all those amazing features. And when are &lt;strong&gt;you&lt;/strong&gt; joining us? :)&lt;/p&gt;

&lt;p&gt;Give Elixir a try! You can start with our &lt;a href="/getting-started/introduction.html"&gt;getting started guide&lt;/a&gt;, or &lt;a href="http://www.youtube.com/watch?v=a-off4Vznjs&amp;amp;feature=youtu.be"&gt;check this 30 minute video from PragProg&lt;/a&gt; or buy the beta version of &lt;a href="http://pragprog.com/book/elixir/programming-elixir"&gt;Programming Elixir&lt;/a&gt;.&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir on Xen</title>
  <link href="http://elixir-lang.org/blog/2013/05/02/elixir-on-xen/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2013-05-02T00:00:00+00:00</updated>
  <id>/blog/2013/05/02/elixir-on-xen</id>
  <content type="html">&lt;p&gt;Elixir uses Erlang underneath, all the way down. Thanks to this, an Elixir project can run on the recently revealed “OS-less” Erlang VM called LING VM. LING VM is the core technology of &lt;a href="http://erlangonxen.org"&gt;Erlang on Xen&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="why-xen"&gt;Why Xen?&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Xen"&gt;Xen&lt;/a&gt; is an open-source baremetal hypervisor that allows many operating systems to run on the same hardware. Xen is frequently used for server virtualization, Infrastructure as a Service (IaaS) and security applications.&lt;/p&gt;

&lt;p&gt;Elixir on Xen runs on top of the Xen Hypervisor (via the LING VM) but with no traditional OS underneath it, taking away numerous administrative, scalability, and performance issues. This  limits options of a malicious attacker, making it an excellent choice for high-security applications, and reduces startup latency, allowing developers to spawn new VMs in less than 100 miliseconds.&lt;/p&gt;

&lt;p&gt;You can learn more about Xen and the LING VM on the &lt;a href="http://erlangonxen.org"&gt;Erlang on Xen website&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="getting-started"&gt;Getting started&lt;/h2&gt;

&lt;p&gt;In order to run Elixir on the LING VM, you need to produce a Xen image of your Elixir project. This can be done with the help of the &lt;a href="http://github.com/maximk/lingex"&gt;lingex project&lt;/a&gt;, created by the LING VM team.&lt;/p&gt;

&lt;p&gt;Producing an Elixir image using the free Erlang on Xen Build Service requires just a few steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Add a dependency on &lt;code&gt;lingex&lt;/code&gt; to your &lt;code&gt;mix.exs&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;  def deps do
    [ { :lingex, github: &amp;quot;maximk/lingex&amp;quot; } ]
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run &lt;code&gt;mix deps.get&lt;/code&gt; to update your dependencies. This adds a few custom tasks
to the mix tool (&lt;code&gt;lingex.build&lt;/code&gt;, &lt;code&gt;lingex.image&lt;/code&gt;, and &lt;code&gt;lingex.build_image&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Set &lt;code&gt;lingex&lt;/code&gt; options. Add the following lines to your &lt;code&gt;mix.exs&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;  def project do
    [ lingex_opts: [
        build_host: &amp;quot;build.erlangonxen.org:8080&amp;quot;,
            username: &amp;quot;test&amp;quot;,
            password: &amp;quot;test&amp;quot; ] ]
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Optionally, you may register with the build service &lt;a href="http://build.erlangonxen.org/register"&gt;here&lt;/a&gt; and update the credentials accordingly. For the complete list of recognized options see the build service documentation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run &lt;code&gt;mix lingex.build_image&lt;/code&gt;. This will archive all &lt;code&gt;*.beam&lt;/code&gt; files of your project and submit them to the build service.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The build process will complete in about 30s. An image file called &amp;#39;vmling&amp;#39; will appear in the current directory, ready to boot as a Xen guest. The image file will contain LING VM and your project code.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And this is all. Erlang on Xen is going to boot the Erlang VM and the standard Erlang shell. You can access Elixir shell in a couple steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In the Erlang shell, first start IEx:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;  1&amp;gt; application:start(iex).
  ok
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Then hit &lt;code&gt;Ctrl+G&lt;/code&gt;. This will open up the user switch command interface from the Erlang shell.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In the user switch interface, type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;  User switch command
   --&amp;gt; s &amp;#39;Elixir.IEx&amp;#39;
   --&amp;gt; c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This will bring you to Interactive Elixir and you can execute Elixir expressions as usual!&lt;/p&gt;

&lt;h2 id="summing-up"&gt;Summing up&lt;/h2&gt;

&lt;p&gt;Running Elixir on Xen opens up many possibilities to Elixir developers. We are very thankful for the work done by &lt;a href="http://erlangonxen.org"&gt;Erlang on Xen team&lt;/a&gt;, who added support for Elixir and the &lt;code&gt;lingex&lt;/code&gt; build tool.&lt;/p&gt;

&lt;p&gt;Erlang on Xen (and consequently Elixir on Xen) is still in active development, so don&amp;#39;t forget to read more about its concepts, use cases and limitations on &lt;a href="http://erlangonxen.org/"&gt;Erlang on Xen website&lt;/a&gt;.&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.8.2 released</title>
  <link href="http://elixir-lang.org/blog/2013/04/29/elixir-v0-8-2-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2013-04-29T00:00:00+00:00</updated>
  <id>/blog/2013/04/29/elixir-v0-8-2-released</id>
  <content type="html">&lt;p&gt;The past week we have released Elixir v0.8.2. It contains many bug fixes and better support for Erlang R16, including &lt;a href="https://github.com/elixir-lang/elixir/commit/0fad1883df9da541628e8485d28372fd4b977b89"&gt;the new built-in functions &lt;code&gt;insert_elem/3&lt;/code&gt; and &lt;code&gt;delete_elem/2&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We have also added extensive support to ANSI escape codes. For example, by simply upgrading to the latest Elixir you will get colored output from your test suites:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/exunit-ansi.png" alt="ANSI escape with ExUnit"&gt;&lt;/p&gt;

&lt;p&gt;We have also added colored output to Interactive Elixir (IEx) but it requires Erlang R16.&lt;/p&gt;

&lt;p&gt;Finally, Elixir has always given special attention to documentation. You can easily document functions with the &lt;code&gt;@doc&lt;/code&gt; attribute:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmodule&lt;/span&gt; &lt;span class="nc"&gt;Math&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="na"&gt;@doc&lt;/span&gt; &lt;span class="sh"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sh"&gt;  Add two numbers together.&lt;/span&gt;

&lt;span class="sh"&gt;  &lt;/span&gt;&lt;span class="err"&gt;##&lt;/span&gt;&lt;span class="sh"&gt; Examples&lt;/span&gt;

&lt;span class="sh"&gt;      iex&amp;gt; Math.add(1, 2)&lt;/span&gt;
&lt;span class="sh"&gt;      3&lt;/span&gt;

&lt;span class="sh"&gt;  &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
  &lt;span class="kd"&gt;def&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The documentation above is embedded into the module and can be easily retrieved at runtime. For example, by typing &lt;code&gt;h Math.add/2&lt;/code&gt; into Interactive Elixir, we can access the documentation for that module.&lt;/p&gt;

&lt;p&gt;Elixir v0.8.2 takes this to the next level by adding support to doctests. Given the example above, you can configure Elixir to automatically run the code samples in your documentation by including a call to the &lt;code&gt;doctest&lt;/code&gt; macro in your test suite:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmodule&lt;/span&gt; &lt;span class="nc"&gt;MathTest&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="kn"&gt;use&lt;/span&gt; &lt;span class="nc"&gt;ExUnit.Case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;async&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;true&lt;/span&gt;
  &lt;span class="n"&gt;doctest&lt;/span&gt; &lt;span class="nc"&gt;Math&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can learn more about &lt;a href="/docs/stable/ex_unit/#!ExUnit.DocTest.html"&gt;doctests on our documentation page&lt;/a&gt; and get more information about our latest release &lt;a href="https://github.com/elixir-lang/elixir/blob/ed27611f48ba150404c95fe15f1d6058a4287330/CHANGELOG.md"&gt;on the CHANGELOG&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you are new to Elixir, &lt;a href="/getting-started/introduction.html"&gt;it&amp;#39;s easy to get started with&lt;/a&gt;!&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Google Summer of Code 2013</title>
  <link href="http://elixir-lang.org/blog/2013/04/19/google-summer-of-code-2013/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2013-04-19T00:00:00+00:00</updated>
  <id>/blog/2013/04/19/google-summer-of-code-2013</id>
  <content type="html">&lt;p&gt;We are pleased to announce that Elixir is taking part in Google Summer of Code 2013
as member of the &lt;a href="http://beamcommunity.github.io"&gt;BEAM Community&lt;/a&gt;. This means that
students all around the world can get paid to work on Elixir during the summer!&lt;/p&gt;

&lt;p&gt;The rules require students to be enrolled in college full or part-time, and to be
at least 18 years by May 27, 2013. You can find more information on
&lt;a href="http://www.google-melange.com/gsoc/homepage/google/gsoc2013"&gt;Google Summer of Code 2013 website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We have published &lt;a href="https://github.com/beamcommunity/beamcommunity.github.com/wiki/Project:-Elixir"&gt;a list of ideas we would like to see and explore in Elixir&lt;/a&gt;
that students can use as a basis, but students are also free to send their own
proposals. If your proposal gets accepted, Google will pay you $5000 over the
course of three months to work on Elixir. Students can start submitting their
proposals on April 22 and the deadline is May 23.&lt;/p&gt;

&lt;p&gt;Note the BEAM Community serves as a mentoring organization for many other projects
that run on the Erlang VM, including Elixir. To see the full list, &lt;a href="http://beamcommunity.github.io"&gt;visit the website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We hope to work with you during this summer! If you have more questions, feel free
to join the &lt;a href="https://groups.google.com/d/forum/beam-community"&gt;BEAM Community mailing list&lt;/a&gt;
or talk to us on &lt;code&gt;#beam-community&lt;/code&gt; on irc.freenode.net.&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.8.0 released</title>
  <link href="http://elixir-lang.org/blog/2013/01/27/elixir-v0-8-0-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2013-01-27T00:00:00+00:00</updated>
  <id>/blog/2013/01/27/elixir-v0-8-0-released</id>
  <content type="html">&lt;p&gt;On the last 9th January, we celebrated &lt;a href="https://github.com/elixir-lang/elixir/commit/337c3f2d569a42ebd5fcab6fef18c5e012f9be5b"&gt;two years since Elixir&amp;#39;s first commit&lt;/a&gt; and to celebrate this occasion we have prepared a big release. Elixir v0.8 is out, with documentation, optimizations, bug fixes and shiny new features. Let&amp;#39;s take a look at them!&lt;/p&gt;

&lt;h2 id="otp-applications"&gt;OTP applications&lt;/h2&gt;

&lt;p&gt;One of the goals for the v0.8 release was better integration with OTP applications. By passing the &lt;code&gt;--sup&lt;/code&gt; option to Mix, you can start a new OTP Application containing application callbacks and a supervisor:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;mix new my_app --sup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And applications can be started directly from the command line as well:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;elixir --app my_app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We have written a whole &lt;a href="/getting-started/mix-otp/supervisor-and-application.html"&gt;guide chapter about creating OTP applications, supervisors and servers&lt;/a&gt;. Give it a try!&lt;/p&gt;

&lt;h2 id="improved-unicode-support"&gt;Improved Unicode support&lt;/h2&gt;

&lt;p&gt;Elixir favors the use of utf-8 binaries since its first release. In the latest releases, we took it up a notch by adding Unicode support, built upon the Unicode Standard 6.2.0. Elixir v0.8 takes this even further, adding more convenience functions and better support to named sequences:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="nc"&gt;String&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capitalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ﬁN&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;#=&amp;gt; &amp;quot;Fin&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The example above contains a string with only two codepoints, &lt;a href="http://www.fileformat.info/info/unicode/char/FB01/index.htm"&gt;the codepoint ﬁ&lt;/a&gt; and &lt;a href="http://www.fileformat.info/info/unicode/char/006E/index.htm"&gt;the codepoint n&lt;/a&gt;. Look how Elixir properly capitalizes the string, returning a new string made of three codepoints (all ascii letters).&lt;/p&gt;

&lt;p&gt;Learn more about &lt;a href="/docs/stable/elixir/#!String.html"&gt;Unicode support with the String module&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="ast-metadata"&gt;AST metadata&lt;/h2&gt;

&lt;p&gt;As per this release, Elixir AST nodes can contain metadata. This metadata is compilation time only but may allow macros to annotate important information in AST nodes, like line numbers, file and other library specific information. If you quote an Elixir expression, we can see the metadata slot:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="k"&gt;quote&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the example above, we can see the AST representation of the expression &lt;code&gt;hello(&amp;quot;world&amp;quot;)&lt;/code&gt;. It is made of a tuple of three elements, the first one is the function name represented by the atom &lt;code&gt;:hello&lt;/code&gt;, the second one is a keyword list containing metadata (in this case, no metadata is available) and the third is a list of arguments, containing the string &amp;quot;world&amp;quot;.&lt;/p&gt;

&lt;p&gt;By default, &lt;code&gt;quote&lt;/code&gt; does not annotate line numbers, but we can pass it as an option:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="k"&gt;quote&lt;/span&gt; &lt;span class="ss"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;__ENV__&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, we can see the metadata spot being used to annotate the line number. This change allowed us to take our macros one step further...&lt;/p&gt;

&lt;h2 id="macros-expansion"&gt;Macros expansion&lt;/h2&gt;

&lt;p&gt;Prior to this release, Elixir had limited expansion of imports and aliases. We decided this would be an important issue to tackle in this release, as people are building more and more projects on top of Elixir.&lt;/p&gt;

&lt;p&gt;Imagine you manually implemented &lt;code&gt;unless&lt;/code&gt; as a macro, that does the opposite of &lt;code&gt;if&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="kd"&gt;defmacro&lt;/span&gt; &lt;span class="k"&gt;unless&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="k"&gt;quote&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="k"&gt;unquote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;unquote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When some code call the &lt;code&gt;unless&lt;/code&gt; macro above, in previous Elixir versions, it would expect the &lt;code&gt;if&lt;/code&gt; macro to be available at the caller. This may not be necessarily true and, even worse, another implementation of the &lt;code&gt;if&lt;/code&gt; macro, not compatible to the one above, could be available.&lt;/p&gt;

&lt;p&gt;Elixir v0.8 ensures that the &lt;code&gt;unless&lt;/code&gt; macro above will expand to the same &lt;code&gt;if&lt;/code&gt; macro available when quoted, guaranteeing different libraries can integrate easily without imposing hidden requirements.&lt;/p&gt;

&lt;p&gt;You can read more about &lt;a href="/getting-started/case-cond-and-if.html"&gt;macros in the getting started guide&lt;/a&gt; or &lt;a href="/docs/stable/elixir/#!Kernel.SpecialForms.html#quote/2"&gt;go deep into the quote macro docs&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="a-new-way-to-manipulate-pathnames"&gt;A new way to manipulate pathnames&lt;/h2&gt;

&lt;p&gt;Elixir v0.8 contains a bit of house cleaning too. We have created &lt;a href="/docs/stable/elixir/#!Path.html"&gt;the Path module&lt;/a&gt; to accommodate functions used to manipulate filesystem paths and have also added functions like &lt;a href="/docs/stable/elixir/#!System.html"&gt;&lt;code&gt;System.tmp_dir&lt;/code&gt; and &lt;code&gt;System.user_home&lt;/code&gt;&lt;/a&gt; which are meant to work accross different operating systems and are very handy when scripting.&lt;/p&gt;

&lt;h2 id="the-new-hashdict"&gt;The new HashDict&lt;/h2&gt;

&lt;p&gt;For last but not least, Elixir ships with a &lt;a href="https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/hash_dict.ex"&gt;new HashDict implementation&lt;/a&gt;. In Erlang, there are different key-value store implementations and often you need to pick which one is the best for you based on the average size of the dictionary. Generally speaking, &lt;a href="http://www.erlang.org/doc/man/orddict.html"&gt;orddicts&lt;/a&gt; are efficient and fast when you want to hold a handful of items, otherwise you should consider &lt;a href="http://www.erlang.org/doc/man/gb_trees.html"&gt;gb_trees&lt;/a&gt; unless you want to hold thousands of items, when then &lt;a href="http://www.erlang.org/doc/man/dict.html"&gt;dict&lt;/a&gt; becomes your best option. The fact those implementations do not provide the same API, makes it harder to change your code when you realize another implementation would be better fit.&lt;/p&gt;

&lt;p&gt;For Elixir, we decided to have a single dictionary implementation that would scale as needed. It would start as a compact representation for a handful of items and expand and rehash accordingly as new items are added or removed, providing fast access and modification times on all ranges. We are glad to say our goals were reached and a new &lt;code&gt;HashDict&lt;/code&gt; implementation ships with Elixir v0.8.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s take a look at some benchmarks:&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/hash-dict-fetch.png" alt="Comparison of fetch times with string keys"&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/contents/hash-dict-update.png" alt="Comparison of update times with string keys"&gt;&lt;/p&gt;

&lt;p&gt;For each number of keys, we have measured and normalized those values against &lt;code&gt;HashDict&lt;/code&gt; results. This way it is easy to see which implementation takes more or less time compared to Elixir&amp;#39;s implementation.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;orddict&lt;/code&gt; is still the faster representation for small ranges since it is a simple list. However, &lt;code&gt;HashDict&lt;/code&gt; is able to be relatively fast compared to &lt;code&gt;orddict&lt;/code&gt; for those small ranges and the fastest solution once you have dozens of keys. &lt;a href="https://gist.github.com/436a9d2bca5051a6dfab"&gt;Those results can be verified when using other types as keys as well&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, given &lt;code&gt;HashDict&lt;/code&gt; starts with a compact representation, it also takes less memory. Compared to the &lt;code&gt;dict&lt;/code&gt; implementation, an empty &lt;code&gt;HashDict&lt;/code&gt; takes only 5 words, while &lt;code&gt;dict&lt;/code&gt; takes 47.&lt;/p&gt;

&lt;h2 id="wrapping-up"&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;We continue actively working on Elixir and this release is the &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.8.0/CHANGELOG.md"&gt;result of our efforts on different areas&lt;/a&gt;! We have exciting plans and newer possibilities to explore, as a new release of Erlang OTP also comes out in a couple weeks.&lt;/p&gt;

&lt;p&gt;Also, we previously announced Elixir is going to be released frequently, every 2 to 4 weeks. We have made a small detour to get v0.8.0 out of the door, but we are back to our regular schedule as of today!&lt;/p&gt;

&lt;p&gt;&lt;a href="/getting-started/introduction.html"&gt;Celebrate with us and give Elixir a try&lt;/a&gt;!&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.7.2 released</title>
  <link href="http://elixir-lang.org/blog/2012/12/04/elixir-v0-7-2-released/" />
  
  <author>
    <name>Yurii Rashkovskii</name>
  </author>
  
  <updated>2012-12-04T00:00:00+00:00</updated>
  <id>/blog/2012/12/04/elixir-v0-7-2-released</id>
  <content type="html">&lt;p&gt;Hot out of the oven! We just released Elixir v0.7.2 with a number of delicious improvements.&lt;/p&gt;

&lt;p&gt;One of the most important changes in this minor release is a partial rehaul of
the type specification syntax.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s the gist:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span class="na"&gt;@spec&lt;/span&gt; &lt;span class="n"&gt;myfun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;
&lt;span class="c1"&gt;# becomes&lt;/span&gt;
&lt;span class="na"&gt;@spec&lt;/span&gt; &lt;span class="n"&gt;myfun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;

&lt;span class="na"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;
&lt;span class="c1"&gt;# becomes&lt;/span&gt;
&lt;span class="na"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(...&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;any&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;((...)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;any&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;any&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="na"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# becomes&lt;/span&gt;
&lt;span class="na"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(()&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="na"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# becomes&lt;/span&gt;
&lt;span class="na"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="na"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;do&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# becomes&lt;/span&gt;
&lt;span class="na"&gt;@type&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another change is that Mix now echoes the output of external tools
such as git and rebar, and handles exit status correctly. This have previously
led to some less-than-perfect workflows.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ve also added a more compact and visual form of the &lt;code&gt;function&lt;/code&gt; helper. Now,
instead of &lt;code&gt;function(Enum, :all?, 2)&lt;/code&gt; you can use &lt;code&gt;function(Enum.all?/2)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ve also figured out how to achieve an up to 6x &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.7.2/lib/elixir/lib/kernel.ex#L1386-L1417"&gt;performance increase&lt;/a&gt;
under some circunstances when using records.&lt;/p&gt;

&lt;p&gt;...and &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.7.2/CHANGELOG.md"&gt;many other fixes &amp;amp; improvements&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lastly, but not least importantly, I&amp;#39;d like to mention that we&amp;#39;re very excited about how the community around Elixir is building up. Thank you all for being around and supporting us!&lt;/p&gt;

&lt;p&gt;&lt;a href="/getting-started/introduction.html"&gt;Learn more about Elixir&lt;/a&gt;!&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.7.1 released</title>
  <link href="http://elixir-lang.org/blog/2012/11/18/elixir-v0-7-1-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2012-11-18T00:00:00+00:00</updated>
  <id>/blog/2012/11/18/elixir-v0-7-1-released</id>
  <content type="html">&lt;p&gt;Elixir v0.7.1 was released this weekend to celebrate the end of a two months journey traveling around Europe, United States and Brazil talking about and exposing Elixir to new developers.&lt;/p&gt;

&lt;p&gt;This is a minor release that contains a couple enhancements regarding UTF-8, &lt;a href="http://www.erlang.org/doc/man/dialyzer.html"&gt;dialyzer&lt;/a&gt; support and bug fixes.&lt;/p&gt;

&lt;p&gt;During this time traveling around, we have spoken at many conferences, as &lt;a href="http://thestrangeloop.com/"&gt;Strange Loop&lt;/a&gt;, &lt;a href="http://oredev.org/"&gt;Øredev&lt;/a&gt;, &lt;a href="http://qconsp.com/"&gt;QCon SP&lt;/a&gt; and &lt;a href="http://rupy.eu/"&gt;Rupy&lt;/a&gt; as well as at different companies. Developers from different backgrounds have shown interest in Elixir, &lt;a href="http://spin.atomicobject.com/2012/10/31/elixir-erlang-and-the-dining-philosophers/"&gt;written about it&lt;/a&gt;, joined us at #elixir-lang on freenode and contributed to the language. As of today, Elixir is powered by 51 different contributors!&lt;/p&gt;

&lt;p&gt;In case you missed any of those conferences, &lt;a href="http://vimeo.com/53221562"&gt;the talk I presented at Øredev is available and you can watch it now&lt;/a&gt;. The slides are also available below.&lt;/p&gt;

&lt;p&gt;If you want to hear more about Elixir at a conference or an event, please let us know. Thank you and don&amp;#39;t forget to &lt;a href="/getting-started/introduction.html"&gt;give Elixir a try&lt;/a&gt;!&lt;/p&gt;

&lt;script async class="speakerdeck-embed" data-id="cf4727401449013077d112313d1a82a3" data-ratio="1.2994923857868" src="//speakerdeck.com/assets/embed.js"&gt;&lt;/script&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.7.0 released</title>
  <link href="http://elixir-lang.org/blog/2012/10/20/elixir-v0-7-0-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2012-10-20T00:00:00+00:00</updated>
  <id>/blog/2012/10/20/elixir-v0-7-0-released</id>
  <content type="html">&lt;p&gt;Elixir v0.7.0 was released with bug fixes and many improvements, like a &lt;code&gt;String&lt;/code&gt; module to handle utf-8 binaries and support to environments and nested dependencies in Mix.&lt;/p&gt;

&lt;p&gt;We have also taken important steps into normalizing our APIs. In Erlang, accesses to tuple and lists are one-based and binaries are zero-based, but in Elixir we have normalized all of them to rely on zero-based access.&lt;/p&gt;

&lt;p&gt;This release also includes some backwards incompatible changes, but the majority of changes were first deprecated, meaning your code will run just fine but with warnings. Those warnings will be removed in the next release v0.7.1, which should happen in a 2 to 4 weeks time span.&lt;/p&gt;

&lt;p&gt;For more information, read out the &lt;a href="https://github.com/elixir-lang/elixir/blob/v0.7.0/CHANGELOG.md"&gt;CHANGELOG&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thank you and don&amp;#39;t forget to &lt;a href="/getting-started/introduction.html"&gt;give Elixir a try&lt;/a&gt;!&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.6.0 released</title>
  <link href="http://elixir-lang.org/blog/2012/08/01/elixir-v0-6-0-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2012-08-01T00:00:00+00:00</updated>
  <id>/blog/2012/08/01/elixir-v0-6-0-released</id>
  <content type="html">&lt;p&gt;We have finally released &lt;a href="/"&gt;Elixir&lt;/a&gt; v0.6.0! This release includes a build tool called Mix, support for Erlang typespecs, many improvements to IEx and improved IO, File and Macro support.&lt;/p&gt;

&lt;h2 id="what-39-s-new"&gt;What&amp;#39;s new&lt;/h2&gt;

&lt;p&gt;When &lt;a href="/blog/2012/05/25/elixir-v0-5-0-released/"&gt;we released version v0.5.0&lt;/a&gt;, we have set three major goals for release v0.6.0:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Provide a build tool that makes it easy to create, compile and test Elixir projects;&lt;/li&gt;
&lt;li&gt;Support &lt;a href="http://www.erlang.org/doc/reference_manual/typespec.html"&gt;Erlang typespecs&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;Improve IO and File modules to be more robust and complete.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Our interactive shell (IEx) also had many improvements, thanks to the Elixir developer community. We now have easy access to documentation, remote shells, autocomplete and much more. In order to show you a bit of what you can do in this release, we have prepared a short (~6 min) screencast:&lt;/p&gt;

&lt;iframe src="http://player.vimeo.com/video/46709928" class="video" width="600" height="337" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="http://vimeo.com/46709928"&gt;Elixir v0.6 quick tour - Mix and IEx&lt;/a&gt; from &lt;a href="http://vimeo.com/user3182384"&gt;Plataformatec&lt;/a&gt; on &lt;a href="http://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;#39;s it. For the next months, we will continue improving Elixir (you can see some ideas floating around in the &lt;a href="https://github.com/elixir-lang/elixir/issues"&gt;issues tracker&lt;/a&gt;) but we will start to focus on other tools and libraries for the community.&lt;/p&gt;

&lt;p&gt;Thank you and don&amp;#39;t forget to &lt;a href="/getting-started/introduction.html"&gt;give Elixir a try&lt;/a&gt;!&lt;/p&gt;
</content>
</entry>

<entry>
  <title>Elixir v0.5.0 released</title>
  <link href="http://elixir-lang.org/blog/2012/05/25/elixir-v0-5-0-released/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2012-05-25T00:00:00+00:00</updated>
  <id>/blog/2012/05/25/elixir-v0-5-0-released</id>
  <content type="html">&lt;p&gt;We have finally released &lt;a href="/"&gt;Elixir&lt;/a&gt; v0.5.0! This marks the first release since the language was rewritten. In this blog post, we will discuss what we achieved during this time and what are the next steps!&lt;/p&gt;

&lt;p&gt;If you don&amp;#39;t care about any of these, you can go straight to our &lt;a href="/getting-started/introduction.html"&gt;Getting Started guide&lt;/a&gt;. If you do, keep on reading!&lt;/p&gt;

&lt;h2 id="looking-back"&gt;Looking back&lt;/h2&gt;

&lt;p&gt;I have started working in Elixir at the beginning of 2011. Around April that year, I had released the version v0.3.0 that was stable enough for me to start using in my own projects. However, after using it in a couple projects quickly reviewed that I was not happy with some of the design decisions taken early on.&lt;/p&gt;

&lt;p&gt;At that time, Elixir attempted to be a considerable departure from Erlang and that revealed very fast to a bad design decision because, in order to use any Erlang module, we first would have to provide an Elixir wrapper for it. Any new function or module in new Erlang releases would have to be wrapped first in Elixir, which means we would always play catch up with Erlang.&lt;/p&gt;

&lt;p&gt;After not feeling productive enough with that Elixir version, I have decided to take a break from Elixir to study old, new and emerging languages. The challenge was to not re-invent Erlang as a language, but how to provide the productivity and flexibility I expect from Elixir while staying a 100% compatible with Erlang.&lt;/p&gt;

&lt;p&gt;It was around October 2011, during a short stay in San Francisco, that I came up with what would be &lt;a href="https://github.com/josevalim/lego-lang"&gt;the foundation of Elixir&amp;#39;s current version&lt;/a&gt; with the help of Yehuda Katz. Development of the new Elixir version started a few days before 2012 and continued steady when the new year came in.&lt;/p&gt;

&lt;p&gt;Around February of that year, feeling confident enough about the direction the language was moving (and initial benchmarks I had made at that point), I have pitched Elixir to &lt;a href="http://plataformatec.com.br/"&gt;my company, Plataformatec&lt;/a&gt;, and they have accepted to sponsor Elixir. With their help, Elixir developed even faster and that&amp;#39;s what we are going to take a look next.&lt;/p&gt;

&lt;h2 id="where-we-are"&gt;Where we are&lt;/h2&gt;

&lt;p&gt;One of the goals we have set was to have a good website and documentation before the next official release. With the help of the Plataformatec team, we created a logo for Elixir and put this website live.&lt;/p&gt;

&lt;p&gt;At the same time, &lt;a href="https://bitbucket.org/birkenfeld/pygments-main/pull-request/57/add-elixir-and-elixir-console-lexers"&gt;we were working on pygments support&lt;/a&gt;, a &lt;a href="https://github.com/elixir-lang/ex_doc"&gt;documentation generation tool&lt;/a&gt; and many others. Soon, Github was able to syntax highlight Elixir code and &lt;a href="/"&gt;our API documentation was online&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;At the same time, people started to gather around #elixir-lang channel on irc.freenode.net and &lt;a href="https://github.com/elixir-lang/elixir/tree/master/lib/mix"&gt;play with Elixir&lt;/a&gt;, &lt;a href="https://github.com/guedes/exdate"&gt;start their&lt;/a&gt; &lt;a href="https://github.com/yrashk/validatex"&gt;own projects&lt;/a&gt; and &lt;a href="https://github.com/alco/elixir/wiki/Erlang-Syntax:-A-Crash-Course"&gt;tutorials&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Although the initial release was scheduled to April 2012, the feedback from such early developers forced us to review some design and syntax decisions and were extremely important to shape the language as it is today.&lt;/p&gt;

&lt;p&gt;With v0.5.0 finally out, we are committing to a stable syntax and a basic standard library. In the last couple days before the release, we have been working on streamlining the documentation and ensure Elixir works on Mac, Linux and Windows machines!&lt;/p&gt;

&lt;h2 id="looking-forward"&gt;Looking forward&lt;/h2&gt;

&lt;p&gt;There are still many, many things to do! In the next months, we will continue working on growing our community, talks and other documentation material. A huge thanks to &lt;a href="http://twitter.com/true_droid"&gt;Alexei Sholik&lt;/a&gt; who is moving this area forward.&lt;/p&gt;

&lt;p&gt;We will also work on better integration and documentation on building Erlang systems. Erlang ships with the &lt;a href="http://en.wikipedia.org/wiki/Open_Telecom_Platform"&gt;Open Telecom Platform&lt;/a&gt; which provides many tools to build distributed applications. In v0.5.0, all these tools are already available but we want to make the build process even simpler.&lt;/p&gt;

&lt;p&gt;In parallel, we will improve our &lt;a href="https://github.com/elixir-lang/ex_doc"&gt;documentation generation tool&lt;/a&gt; and &lt;a href="https://github.com/elixir-lang/elixir/tree/master/lib/mix"&gt;build tool&lt;/a&gt; which will likely be merged into core when they are solid enough.&lt;/p&gt;

&lt;p&gt;Finally, we will continue improving the Standard Library. Although Elixir&amp;#39;s goal is to rely on Erlang the most as possible, we also want to provide a small Standard Library which makes better use of Elixir semantics. For the next weeks, we will focus on improving the IO and File manipulation modules. New data types may also appear, for example, ranges come to my mind.&lt;/p&gt;

&lt;p&gt;Check out our &lt;a href="/"&gt;home page&lt;/a&gt; and the &lt;a href="/getting-started/introduction.html"&gt;getting started guide&lt;/a&gt; for more information. Welcome aboard and grab a cup of Elixir, because you are certainly going to enjoy the ride!&lt;/p&gt;
</content>
</entry>

<entry>
  <title>A peek inside Elixir's Parallel Compiler</title>
  <link href="http://elixir-lang.org/blog/2012/04/24/a-peek-inside-elixir-s-parallel-compiler/" />
  
  <author>
    <name>José Valim</name>
  </author>
  
  <updated>2012-04-24T00:00:00+00:00</updated>
  <id>/blog/2012/04/24/a-peek-inside-elixir-s-parallel-compiler</id>
  <content type="html">&lt;p&gt;Today, a parallel compiler just landed in Elixir master. The goal of the parallel compiler is to compile files in parallel, automatically detecting dependencies between files. In this blog post, we are going to take a peek into the parallel compiler internals and learn more about Erlang and Elixir in the process.&lt;/p&gt;

&lt;h2 id="process-based-serial-compilation"&gt;Process-based serial compilation&lt;/h2&gt;

&lt;p&gt;The idea of the parallel compiler is very simple: for each file we want to compile, we will spawn a new process that will be responsible for its compilation. When compilation finishes, the process is going to send a message to the main process (the one responsible for coordinating compilation) that compilation finished so a new file can be compiled.&lt;/p&gt;

&lt;p&gt;In Elixir, we could write this code as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;def spawn_compilers([current|files], output) do
  parent = Process.self()
  child  = spawn_link(fn -&amp;gt;
    :elixir_compiler.file_to_path(current, output)
    send parent, { :compiled, Process.self() }
  end)
  receive do
    { :compiled, ^child } -&amp;gt;
      spawn_compilers(files, output)
    { :EXIT, ^child, { reason, where } } -&amp;gt;
      :erlang.raise(:error, reason, where)
  end
end

def spawn_compilers([], _output) do
  :done
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the first line, we define a function named &lt;code&gt;spawn_compilers&lt;/code&gt; that receives two arguments, the first is a list of files to compile and the second is a string telling us where to write the compiled file. The first argument is represented as a list with head and tail (&lt;code&gt;[current|files]&lt;/code&gt;) where the top of the list is assigned to &lt;code&gt;current&lt;/code&gt; and the remaining items to &lt;code&gt;files&lt;/code&gt;. If the list is empty, the first clause of &lt;code&gt;spawn_compilers&lt;/code&gt; is not going to match, the clause &lt;code&gt;spawn_compilers([], _output)&lt;/code&gt; defined at the end will instead.&lt;/p&gt;

&lt;p&gt;Inside &lt;code&gt;spawn_compilers&lt;/code&gt;, we first retrieve the PID of the current process with &lt;code&gt;Process.self&lt;/code&gt; (remember we are talking about Erlang processes/actors and not OS processes) and then proceed to spawn a new process to execute the given function in parallel. Spawning a new process is done with the &lt;code&gt;spawn_link&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;spawn_link&lt;/code&gt; function starts a new process and automatically links the current (parent) process with the spawned (child) one, returning the child PID. By linking the process we ensure that, if the child process dies, a message will be sent to the parent process which then can act on it.&lt;/p&gt;

&lt;p&gt;The function given to &lt;code&gt;spawn_link&lt;/code&gt; is quite straight-forward. It simply invokes an Erlang function as &lt;code&gt;:elixir_compiler.file_to_path&lt;/code&gt; and then proceeds to send a message to the parent process notifying that compilation finished.&lt;/p&gt;

&lt;p&gt;After the child process is spawned, we invoke the &lt;code&gt;receive&lt;/code&gt; macro and start waiting for messages. At this point, we are expecting two types of messages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;{ :compiled, ^child }&lt;/code&gt; - a message sent by the child informing us that compilation finished. Note that use of &lt;code&gt;^&lt;/code&gt; before the variable &lt;code&gt;child&lt;/code&gt; to tell Elixir to match the current value of &lt;code&gt;child&lt;/code&gt; with the one received in the message. If compilation succeeds, we move forward and spawn the next child by calling &lt;code&gt;spawn_compilers&lt;/code&gt; recursively;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;{ :EXIT, ^child, { reason, where } }&lt;/code&gt; - this is the message sent by the child process in case it dies. This message is only received if the child is started via &lt;code&gt;spawn_link&lt;/code&gt;. In the message, we can find the reason why it failed and the stacktrace. We then proceed to call an Erlang internal function to re-raise the error in the main process, effectively stopping compilation.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With this code, we were able to compile each file inside a different process. However, notice that we are not yet compiling in parallel. Every time we spawn a child process, we wait until it succeeds (or fails) before moving to the next step. We are going to eventually compile files in parallel, but before we reach to this point, let&amp;#39;s understand the problem of dependencies between files.&lt;/p&gt;

&lt;h2 id="dependency-between-files"&gt;Dependency between files&lt;/h2&gt;

&lt;p&gt;Imagine that we have two files, &lt;code&gt;a.ex&lt;/code&gt; and &lt;code&gt;b.ex&lt;/code&gt;, with the following contents:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;# a.ex
defmodule A do
  B.define
end

# b.ex
defmodule B do
  defmacro define do
    quote do
      def one, do: 1
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to compile &lt;code&gt;A&lt;/code&gt;, we need to ensure that &lt;code&gt;B&lt;/code&gt; is already compiled and loaded so we can invoke the &lt;code&gt;define&lt;/code&gt; macro. This means the file &lt;code&gt;a.ex&lt;/code&gt; depends on the file &lt;code&gt;b.ex&lt;/code&gt;. When compiling files in parallel, we want to be able to detect such cases and automatically handle them.&lt;/p&gt;

&lt;p&gt;The way we are going to handle this is by pausing compilation every time a module that was not yet defined is invoked. In this case, when compiling the file &lt;code&gt;a.ex&lt;/code&gt; and &lt;code&gt;B.define&lt;/code&gt; is invoked, the process responsible for compiling &lt;code&gt;a.ex&lt;/code&gt; is going to pause and notify our main process. The main process will then start the compilation of other files. Whenever the module &lt;code&gt;B&lt;/code&gt; is compiled, the main process is going to tell the process responsible for &lt;code&gt;a.ex&lt;/code&gt; to resume compilation since its dependency &lt;code&gt;B&lt;/code&gt; is now available.&lt;/p&gt;

&lt;p&gt;In order to customize this process, we are going to take a look at Erlang&amp;#39;s error handler.&lt;/p&gt;

&lt;h2 id="custom-error-handler"&gt;Custom error handler&lt;/h2&gt;

&lt;p&gt;By default, Elixir (and Erlang) code is autoloaded. This means that, if we invoke &lt;code&gt;List.delete&lt;/code&gt; and the module &lt;code&gt;List&lt;/code&gt; was not loaded yet, the Erlang VM is going to look into the &lt;code&gt;ebin&lt;/code&gt; directory (the directory where we put compiled files) and try to load it. This process is controlled by the &lt;a href="http://erlang.org/doc/man/error_handler.html"&gt;&lt;code&gt;error_handler&lt;/code&gt; module in Erlang&lt;/a&gt; via two callback functions: &lt;code&gt;undefined_function&lt;/code&gt; and &lt;code&gt;undefined_lambda&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As discussed in the previous section, we want to extend the error handler to actually stop the currently running process whenever a module is not found and resume the process only after we ensure the module is compiled. To do that, we can simply define our own error handler and ask Erlang to use it. Our custom error handler is defined as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;defmodule Elixir.ErrorHandler do
  def undefined_function(module, fun, args) do
    ensure_loaded(module)
    :error_handler.undefined_function(module, fun, args)
  end

  def undefined_lambda(module, fun, args) do
    ensure_loaded(module)
    :error_handler.undefined_lambda(module, fun, args)
  end

  defp ensure_loaded(module) do
    case Code.ensure_loaded(module) do
      { :module, _ } -&amp;gt;
        []
      { :error, _ } -&amp;gt;
        parent = Process.get(:elixir_parent_compiler)
        send parent, { :waiting, Process.self, module }
        receive do
          { :release, ^parent } -&amp;gt; ensure_loaded(module)
        end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Our error handler defines two public functions. Both those functions are callbacks required to be implemented by the error handler. They simply call &lt;code&gt;ensure_loaded(module)&lt;/code&gt; and then delegate the remaining logic to Erlang&amp;#39;s original &lt;code&gt;error_handler&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The private &lt;code&gt;ensure_loaded&lt;/code&gt; function calls &lt;code&gt;Code.ensure_loaded(module)&lt;/code&gt; which checks if the given module is loaded and, if not, tries to load it. In case it succeeds, it returns &lt;code&gt;{ :module, _ }&lt;/code&gt;, which means the module is available and we don&amp;#39;t need to stop the current process. However, if it returns &lt;code&gt;{ :error, _ }&lt;/code&gt;, it means the module cannot be found and we need to wait until it is compiled. For that, we invoke &lt;code&gt;Process.get(:elixir_parent_compiler)&lt;/code&gt; to get the PID of the main process so we can notify it that we are waiting on a given module. Then we invoke the macro &lt;code&gt;receive&lt;/code&gt; as a way to stop the current process until we receive a message from the parent saying new modules are available, starting the flow again.&lt;/p&gt;

&lt;p&gt;With our error handler code in place, the first thing we need to do is to change the function given to &lt;code&gt;spawn_link&lt;/code&gt; to use the new error handler:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;spawn_link(fn -&amp;gt;
  Process.put(:elixir_parent_compiler, parent)
  Process.flag(:error_handler, Elixir.ErrorHandler)

  :elixir_compiler.file_to_path(current, output)
  send parent, { :compiled, Process.self() }
end)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice that we have two small additions. First we store the &lt;code&gt;:elixir_parent_compiler&lt;/code&gt; PID in the process dictionary so we are able to read it from the error handler and then we proceed to configure a flag in our process so our new error handler is invoked whenever a module or function cannot be found.&lt;/p&gt;

&lt;p&gt;Second, our main process can now receive a new &lt;code&gt;{ :waiting, child, module }&lt;/code&gt; message, so we need to extend it to account for those messages. Not only that, we need to control which PIDs we have spawned so we can notify them whenever a new module is compiled, forcing us to add a new argument to the &lt;code&gt;spawn_compilers&lt;/code&gt; function. &lt;code&gt;spawn_compilers&lt;/code&gt; would then be rewritten as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;def spawn_compilers([current|files], output, stack) do
  parent = Process.self()
  child  = spawn_link(fn -&amp;gt;
    :elixir_compiler.file_to_path(current, output)
    send parent, { :compiled, Process.self() }
  end)
  wait_for_messages(files, output, [child|stack])
end

# No more files and stack is empty, we are done
def spawn_compilers([], _output, []) do
  :done
end

# No more files and stack is not empty, wait for all messages
def spawn_compilers([], output, stack) do
  wait_for_messages([], output, stack)
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice we added an extra clause to &lt;code&gt;spawn_compilers&lt;/code&gt; so we can properly handle the case where we don&amp;#39;t have more files to spawn but we are still waiting for processes in the stack. We have also moved our &lt;code&gt;receive&lt;/code&gt; logic to a new private function called &lt;code&gt;wait_for_messages&lt;/code&gt;, implemented as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;code class="language-text" data-lang="text"&gt;defp wait_for_messages(files, output, stack) do
  receive do
    { :compiled, child } -&amp;gt;
      new_stack = List.delete(stack, child)
      Enum.each new_stack, fn(pid) -&amp;gt;
        send pid, { :release, Process.self }
      end
      spawn_compilers(files, output, new_stack)
    { :waiting, _child, _module } -&amp;gt;
      spawn_compilers(files, output, stack)
    { :EXIT, _child, { reason, where } } -&amp;gt;
      :erlang.raise(:error, reason, where)
  after
    10_000 -&amp;gt;
      raise &amp;quot;dependency on unexesting module or possible deadlock&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The implementation for &lt;code&gt;wait_for_messages&lt;/code&gt; is now broken into 4 clauses:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;{ :compiled, child }&lt;/code&gt; - Similar as before, it is the notification a child processed finished compilation. Every time we receive such notifications, we remove the child PID from the stack and notify the remaining PIDs in the stack that new modules are available. Notice that we no longer match on a specific &lt;code&gt;^child&lt;/code&gt; PID, since now we can receive messages from different children at the same time;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;{ :waiting, _child, _module }&lt;/code&gt; - A message received every time a child process is waiting on a module to be compiled. In this scenario, all we do is spawn a new process to compile another file, ensuring compilation is never blocked;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;{ :EXIT, _child, { reason, where } }&lt;/code&gt; - The same behaviour as before, it simply raises an error if any of the child processes fail;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;after: 10_000&lt;/code&gt; - This clause is going to be invoked whenever the main process does not receive a message for 10 seconds. This means a file depends on a module that does not exist (and therefore waits forever) or there is a cyclic dependency;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And that&amp;#39;s all we need to have a basic version of our parallel compilation working. Notice we start compiling only one file at a time but, as soon as we depend on other files, the number of PIDs in the stack starts to grow. If we wanted, we could modify the code to make use of a head start and compile more than one file since the beginning.&lt;/p&gt;

&lt;p&gt;It is important to notice that this code has room for improvements. First, every time a new module is compiled, we notify all child process that new modules are available. This is a waste of resource if we consider that the child modules tells us explicitly on which modules they are waiting on. Therefore, the code could be modified to store a mapping from each child process to the module it is waiting for so that when a new module is compiled, only the children that depend on it are notified.&lt;/p&gt;

&lt;p&gt;Also, if we start storing which module each process is depending on, we are able to know whenever we have a deadlock or a dependency on an nonexistent file, allowing us to get rid of the timeout.&lt;/p&gt;

&lt;p&gt;All those improvements and other goodies like callbacks are implemented in Elixir source code and we recommend you take a look at both the &lt;a href="https://github.com/elixir-lang/elixir/blob/6182602f1205e2d9fc54666e0721270a27226fbc/lib/elixir/parallel_compiler.ex"&gt;Elixir.ParallelCompiler&lt;/a&gt; and &lt;a href="https://github.com/elixir-lang/elixir/blob/6182602f1205e2d9fc54666e0721270a27226fbc/lib/elixir/error_handler.ex"&gt;Elixir.ErrorHandler&lt;/a&gt; modules to see all the details firsthand.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</content>
</entry>

 
</feed>
